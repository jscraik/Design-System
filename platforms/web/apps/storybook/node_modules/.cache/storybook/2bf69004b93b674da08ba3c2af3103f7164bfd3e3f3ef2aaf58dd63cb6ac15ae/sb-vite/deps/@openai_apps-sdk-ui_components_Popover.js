import "./chunk-JGD3YD3T.js";
import "./chunk-JDJKLYFM.js";
import "./chunk-Z3HHH7UU.js";
import "./chunk-ERAWCXHU.js";
import "./chunk-MGU2YMFG.js";
import "./chunk-6RWZJEBT.js";
import "./chunk-KYNL3UK3.js";
import "./chunk-TWQYYV7I.js";
import "./chunk-EZTAIBVW.js";
import "./chunk-55H34JF6.js";
import "./chunk-GVXYQAHP.js";
import "./chunk-I7RT4C2S.js";
import "./chunk-LQQIGTWM.js";
import "./chunk-UOXWGAE7.js";
import "./chunk-AETNVWQ3.js";
import "./chunk-YP56DS4C.js";
import "./chunk-7E4YQIQW.js";
import "./chunk-T3PSF3NT.js";
import "./chunk-S33EG3ST.js";
import {
  TransitionGroup,
  useTimeout
} from "./chunk-QFBUIEQY.js";
import {
  focusableElements,
  preventDefaultHandler,
  toCssVariables,
  waitForAnimationFrame
} from "./chunk-PJFYJN5I.js";
import "./chunk-PY76LLNJ.js";
import {
  clsx_default
} from "./chunk-SB4CO3B7.js";
import "./chunk-AQOEJAA3.js";
import "./chunk-JTEKTU36.js";
import {
  dist_exports
} from "./chunk-C27VTHKJ.js";
import "./chunk-T6XA5KF5.js";
import "./chunk-IZ6CW34S.js";
import "./chunk-LQXRCXRD.js";
import "./chunk-AU4SHAIK.js";
import "./chunk-7XJWAJMF.js";
import "./chunk-WDNP7B72.js";
import "./chunk-YHAOBUKW.js";
import "./chunk-ELVH5QQ3.js";
import "./chunk-YLI5SDSM.js";
import "./chunk-5UH377FE.js";
import "./chunk-RTEN47ZZ.js";
import "./chunk-ZQTXD7KB.js";
import "./chunk-O3NXVIVX.js";
import "./chunk-TGDLAPPE.js";
import "./chunk-F5ZMPZBT.js";
import "./chunk-ZT7L6GKW.js";
import "./chunk-4GTTS5F7.js";
import "./chunk-FHFLLR6N.js";
import "./chunk-BV4YCWV6.js";
import "./chunk-Y6TFVOQU.js";
import "./chunk-RRLKTXJZ.js";
import "./chunk-M4IDVX4A.js";
import "./chunk-LPEA5PE7.js";
import {
  require_jsx_runtime
} from "./chunk-SOYICBYQ.js";
import {
  require_react_dom
} from "./chunk-G4ZAWCST.js";
import {
  require_react
} from "./chunk-SVZU6VD4.js";
import {
  __toESM
} from "./chunk-PLDDJCW6.js";

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Popover/Popover.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/hooks/useEscCloseStack.js
var import_react2 = __toESM(require_react());

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/hooks/useLatestValue.js
var import_react = __toESM(require_react());
function useLatestValue(value) {
  const ref = (0, import_react.useRef)(value);
  ref.current = value;
  return ref;
}

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/hooks/useEscCloseStack.js
var handlers = [];
var listenerBound = false;
var handleKeyDown = (evt) => {
  if (evt.key === "Escape") {
    const [firstHandler] = handlers;
    if (firstHandler) {
      evt.preventDefault();
      firstHandler.callback.current?.();
    }
  }
};
var managerListener = () => {
  if (handlers.length > 0 && !listenerBound) {
    document.body.addEventListener("keydown", handleKeyDown);
    listenerBound = true;
  } else if (handlers.length === 0 && listenerBound) {
    document.body.removeEventListener("keydown", handleKeyDown);
    listenerBound = false;
  }
};
var registerHandler = (handler) => {
  handlers.unshift(handler);
  managerListener();
};
var unregisterHandler = ({ id }) => {
  handlers = handlers.filter((h) => h.id !== id);
  managerListener();
};
var useEscCloseStack = (listening, cb) => {
  const id = (0, import_react2.useId)();
  const latestCallback = useLatestValue(cb);
  (0, import_react2.useEffect)(() => {
    if (!listening) {
      return;
    }
    const handler = { id, callback: latestCallback };
    registerHandler(handler);
    return () => unregisterHandler(handler);
  }, [id, listening, latestCallback]);
};

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Popover/pointerIntent.js
var createPointerIntentArea = (event, hoverTarget) => {
  const currentTarget = event.currentTarget;
  const exitPoint = { x: event.clientX, y: event.clientY };
  const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
  const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
  const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
  const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
  return graceArea;
};
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y + padding }, { x: exitPoint.x + padding, y: exitPoint.y + padding });
      break;
    case "bottom":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, { x: exitPoint.x + padding, y: exitPoint.y - padding });
      break;
    case "left":
      paddedExitPoints.push({ x: exitPoint.x + padding, y: exitPoint.y - padding }, { x: exitPoint.x + padding, y: exitPoint.y + padding });
      break;
    case "right":
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, { x: exitPoint.x - padding, y: exitPoint.y + padding });
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Popover/Popover.js
import s from "/Users/jamiecraik/dev/aStudio/node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Popover/Popover.module.css";

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Popover/usePopoverContext.js
var import_react3 = __toESM(require_react());
var PopoverContext = (0, import_react3.createContext)(null);
var usePopoverContext = () => {
  const context = (0, import_react3.use)(PopoverContext);
  if (!context) {
    throw new Error("Popover components must be wrapped in <Popover />");
  }
  return context;
};

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Popover/Popover.js
var Popover = ({ open: controlledOpen, onOpenChange: controlledOnOpenChange, showOnHover = false, hoverOpenDelay = 150, children }) => {
  const [open, setOpen] = (0, import_react4.useState)(false);
  const [shake, setShake] = (0, import_react4.useState)(false);
  const triggerRef = (0, import_react4.useRef)(null);
  const contentRef = (0, import_react4.useRef)(null);
  const openTimerRef = (0, import_react4.useRef)(void 0);
  const hoverOpenFocusedWithTab = (0, import_react4.useRef)(false);
  const isPointerInTransitRef = (0, import_react4.useRef)(false);
  const isOpen = controlledOpen ?? open;
  const [temporarilyPreventClickToClose, setTemporarilyPreventClickToClose] = (0, import_react4.useState)(false);
  useTimeout(() => setTemporarilyPreventClickToClose(false), temporarilyPreventClickToClose ? 500 : null);
  const latestOpenChange = useLatestValue(controlledOnOpenChange);
  const handleOpenChangeImpl = useLatestValue((nextState) => {
    clearTimeout(openTimerRef.current);
    if (isOpen === nextState) {
      return;
    }
    if (!nextState) {
      setShake(false);
      if (showOnHover && hoverOpenFocusedWithTab.current) {
        triggerRef.current?.focus();
      }
      hoverOpenFocusedWithTab.current = false;
    }
    latestOpenChange.current?.(nextState);
    setOpen(nextState);
    if (showOnHover) {
      setTemporarilyPreventClickToClose(nextState);
    }
  });
  const handleOpenChange = (0, import_react4.useCallback)((nextState) => {
    handleOpenChangeImpl.current(nextState);
  }, [handleOpenChangeImpl]);
  const handleTriggerEnter = (0, import_react4.useCallback)(() => {
    openTimerRef.current = setTimeout(() => handleOpenChange(true), hoverOpenDelay);
  }, [handleOpenChange, hoverOpenDelay]);
  const handleTriggerLeave = (0, import_react4.useCallback)(() => {
    clearTimeout(openTimerRef.current);
  }, []);
  (0, import_react4.useEffect)(() => {
    return () => {
      clearTimeout(openTimerRef.current);
    };
  }, []);
  const store = (0, import_react4.useMemo)(() => ({
    open: isOpen,
    setOpen: handleOpenChange,
    shake,
    setShake,
    showOnHover,
    temporarilyPreventClickToClose,
    onTriggerEnter: handleTriggerEnter,
    onTriggerLeave: handleTriggerLeave,
    isPointerInTransitRef,
    triggerRef,
    contentRef,
    hoverOpenFocusedWithTab
  }), [
    isOpen,
    handleOpenChange,
    shake,
    setShake,
    showOnHover,
    temporarilyPreventClickToClose,
    hoverOpenFocusedWithTab,
    isPointerInTransitRef,
    handleTriggerEnter,
    handleTriggerLeave
  ]);
  return (0, import_jsx_runtime.jsx)(PopoverContext, { value: store, children: (0, import_jsx_runtime.jsx)(dist_exports.Root, { open: isOpen, onOpenChange: handleOpenChange, modal: false, children }) });
};
var Trigger = ({ children, onPointerDown, onClick }) => {
  const { setOpen, showOnHover, temporarilyPreventClickToClose, onTriggerEnter, onTriggerLeave, isPointerInTransitRef, triggerRef, contentRef } = usePopoverContext();
  const hasPointerMoveOpenedRef = (0, import_react4.useRef)(false);
  const maybePreventClickClose = (evt) => {
    const isLink = evt.currentTarget.nodeName.toLocaleLowerCase() === "a";
    if (!isLink && temporarilyPreventClickToClose) {
      evt.preventDefault();
      evt.stopPropagation();
    }
  };
  const handlePointerMove = (evt) => {
    if (evt.pointerType === "touch") {
      return;
    }
    if (!hasPointerMoveOpenedRef.current && !isPointerInTransitRef.current) {
      onTriggerEnter();
      hasPointerMoveOpenedRef.current = true;
    }
  };
  const handlePointerLeave = () => {
    if (!hasPointerMoveOpenedRef.current) {
      return;
    }
    onTriggerLeave();
    hasPointerMoveOpenedRef.current = false;
  };
  return (0, import_jsx_runtime.jsx)(dist_exports.Trigger, { asChild: true, ref: triggerRef, onPointerDown: (evt) => {
    maybePreventClickClose(evt);
    onPointerDown?.(evt);
  }, onClick: (evt) => {
    maybePreventClickClose(evt);
    onClick?.(evt);
  }, onPointerMove: showOnHover ? handlePointerMove : void 0, onPointerLeave: showOnHover ? handlePointerLeave : void 0, onFocus: showOnHover ? () => setOpen(true) : void 0, onBlur: showOnHover ? () => {
    setTimeout(() => {
      if (contentRef.current?.contains(document.activeElement)) {
        return;
      }
      setOpen(false);
    }, 50);
  } : void 0, children });
};
var ContentImpl = ({ children, avoidCollisions, width, minWidth, maxWidth, side, sideOffset = 8, align, alignOffset, translucent, className, autoFocus = true }) => {
  const { showOnHover, shake, contentRef } = usePopoverContext();
  const handleKeyDown2 = (evt) => {
    const contentElement = contentRef.current;
    if (
      // When the current target is our container
      contentElement && evt.target === contentElement && // We know that shift key tabs will lead to closing the popover (because we don't use `modal`)
      evt.key === "Tab" && evt.shiftKey
    ) {
      evt.preventDefault();
      evt.stopPropagation();
      const focusable = focusableElements(contentElement);
      const lastFocusable = focusable[focusable.length - 1];
      lastFocusable?.focus();
    }
  };
  (0, import_react4.useEffect)(() => {
    const contentElement = contentRef.current;
    if (!contentElement || !autoFocus) {
      return;
    }
    if (contentElement?.contains(document.activeElement)) {
      return;
    }
    if (!showOnHover) {
      contentElement.focus({ preventScroll: true });
    }
  }, [contentRef, showOnHover, autoFocus]);
  return (0, import_jsx_runtime.jsx)(dist_exports.Content, {
    forceMount: true,
    ref: contentRef,
    className: clsx_default(s.Popover, className),
    style: toCssVariables({
      "popover-width": width,
      "popover-min-width": minWidth,
      "popover-max-width": maxWidth
    }),
    onCloseAutoFocus: showOnHover ? preventDefaultHandler : void 0,
    "data-animate": shake ? "shake" : void 0,
    "data-translucent": translucent ? "true" : void 0,
    side,
    sideOffset,
    align,
    alignOffset: alignOffset ?? (align === "center" ? 0 : -5),
    avoidCollisions: avoidCollisions ?? true,
    hideWhenDetached: true,
    collisionPadding: 20,
    onOpenAutoFocus: preventDefaultHandler,
    // Use custom esc listener because default Radix is bound to the document
    // and cannot have propagation stopped.
    onEscapeKeyDown: preventDefaultHandler,
    onKeyDown: handleKeyDown2,
    children
  });
};
var ContentHoverable = (props) => {
  const { setOpen, triggerRef, contentRef, isPointerInTransitRef, hoverOpenFocusedWithTab } = usePopoverContext();
  const [pointerGraceArea, setPointerGraceArea] = (0, import_react4.useState)(null);
  const handleRemoveGraceArea = (0, import_react4.useCallback)(() => {
    setPointerGraceArea(null);
    isPointerInTransitRef.current = false;
  }, [isPointerInTransitRef]);
  const handleCreateGraceArea = (0, import_react4.useCallback)((event, hoverTarget) => {
    const graceArea = createPointerIntentArea(event, hoverTarget);
    setPointerGraceArea(graceArea);
    isPointerInTransitRef.current = true;
  }, [isPointerInTransitRef]);
  (0, import_react4.useEffect)(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  (0, import_react4.useEffect)(() => {
    const trigger = triggerRef.current;
    const content = contentRef.current;
    if (!trigger || !content) {
      return;
    }
    const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
    const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
    trigger.addEventListener("pointerleave", handleTriggerLeave);
    content.addEventListener("pointerleave", handleContentLeave);
    return () => {
      trigger.removeEventListener("pointerleave", handleTriggerLeave);
      content.removeEventListener("pointerleave", handleContentLeave);
    };
  }, [contentRef, triggerRef, handleCreateGraceArea, handleRemoveGraceArea]);
  (0, import_react4.useEffect)(() => {
    if (!pointerGraceArea) {
      return;
    }
    const handleTrackPointerGrace = (event) => {
      const trigger = triggerRef.current;
      const content = contentRef.current;
      const target = event.target;
      const pointerPosition = { x: event.clientX, y: event.clientY };
      const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
      const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
      const targetHasPopup = target.hasAttribute("aria-haspopup");
      if (hasEnteredTarget) {
        handleRemoveGraceArea();
      } else if (isPointerOutsideGraceArea || targetHasPopup) {
        handleRemoveGraceArea();
        setOpen(false);
      }
    };
    document.addEventListener("pointermove", handleTrackPointerGrace);
    return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
  }, [pointerGraceArea, setOpen, handleRemoveGraceArea, triggerRef, contentRef]);
  (0, import_react4.useEffect)(() => {
    const handleKeyDown2 = (evt) => {
      if (!contentRef.current) {
        return;
      }
      if (evt.key === "Tab" && !evt.shiftKey) {
        const [firstFocusable] = focusableElements(contentRef.current);
        if (firstFocusable) {
          evt.preventDefault();
          firstFocusable.focus();
          hoverOpenFocusedWithTab.current = true;
          document.removeEventListener("keydown", handleKeyDown2);
        }
      }
    };
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [contentRef, hoverOpenFocusedWithTab]);
  return (0, import_jsx_runtime.jsx)(ContentImpl, { ...props });
};
var Content = (props) => {
  const { open, showOnHover, setOpen } = usePopoverContext();
  useEscCloseStack(open, () => {
    setOpen(false);
  });
  return (0, import_jsx_runtime.jsx)(dist_exports.Portal, { forceMount: true, children: (0, import_jsx_runtime.jsx)(TransitionGroup, { enterDuration: 600, exitDuration: 300, className: s.Transition, disableAnimations: true, children: open && (showOnHover ? (0, import_jsx_runtime.jsx)(ContentHoverable, { ...props }, "popover-hover") : (0, import_jsx_runtime.jsx)(ContentImpl, { ...props }, "popover")) }) });
};
Popover.Trigger = Trigger;
Popover.Content = Content;

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Popover/usePopoverController.js
var import_react5 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var usePopoverClose = () => {
  const { setOpen } = usePopoverContext();
  return (0, import_react5.useCallback)(() => setOpen(false), [setOpen]);
};
var usePopoverShake = () => {
  const { setShake } = usePopoverContext();
  return (0, import_react5.useCallback)(() => {
    (0, import_react_dom.flushSync)(() => {
      setShake(false);
    });
    waitForAnimationFrame(() => setShake(true));
  }, [setShake]);
};
var usePopoverController = () => {
  const shake = usePopoverShake();
  const close = usePopoverClose();
  return { close, shake };
};
export {
  Popover,
  usePopoverController
};
//# sourceMappingURL=@openai_apps-sdk-ui_components_Popover.js.map
