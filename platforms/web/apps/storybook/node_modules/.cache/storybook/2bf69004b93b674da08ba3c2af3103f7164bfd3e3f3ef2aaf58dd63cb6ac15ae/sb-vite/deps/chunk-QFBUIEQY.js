import {
  isDev,
  isTest,
  toCssVariables,
  toFilterProperty,
  toMsDurationProperty,
  toOpacityProperty,
  toTransformProperty,
  waitForAnimationFrame
} from "./chunk-PJFYJN5I.js";
import {
  o
} from "./chunk-PY76LLNJ.js";
import {
  clsx_default
} from "./chunk-SB4CO3B7.js";
import {
  require_jsx_runtime
} from "./chunk-SOYICBYQ.js";
import {
  require_react
} from "./chunk-SVZU6VD4.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PLDDJCW6.js";

// ../../../../node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "../../../../node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce2;
  }
});

// ../../../../node_modules/.pnpm/usehooks-ts@3.1.1_react@19.0.0/node_modules/usehooks-ts/dist/index.js
var import_react = __toESM(require_react());
var import_lodash = __toESM(require_lodash());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function useTimeout(callback, delay) {
  const savedCallback = (0, import_react.useRef)(callback);
  useIsomorphicLayoutEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react.useEffect)(() => {
    if (!delay && delay !== 0) {
      return;
    }
    const id = setTimeout(() => {
      savedCallback.current();
    }, delay);
    return () => {
      clearTimeout(id);
    };
  }, [delay]);
}

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/getDisableAnimations.js
var getDisableAnimations_default = () => isTest;

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/shared.js
var import_react2 = __toESM(require_react());
var ChildrenWithKeys = (children, shouldThrow = false, componentName = "TransitionGroup") => {
  const validChildren = [];
  import_react2.Children.forEach(children, (child) => {
    if (child && typeof child === "object" && "key" in child && !!child.key) {
      validChildren.push(child);
    } else if (shouldThrow) {
      throw new Error(`Child elements of <${componentName} /> must include a \`key\``);
    }
  });
  return validChildren;
};
var noop = () => {
};
var useChildCallback = (cb) => {
  const ref = (0, import_react2.useRef)(cb);
  ref.current = cb;
  return (0, import_react2.useCallback)((element) => ref.current(element), []);
};
function computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod) {
  const propChildKeyMap = propChildrenArray.reduce((acc, child) => ({ ...acc, [child.key]: 1 }), {});
  const currentRenderChildKeyMap = currentRenderChildren.reduce((acc, child) => ({ ...acc, [child.component.key]: 1 }), {});
  const newRenderChildren = propChildrenArray.filter((propChild) => !currentRenderChildKeyMap[propChild.key]).map(createDefaultRenderChildProps);
  const updatedCurrentChildren = currentRenderChildren.map((childProps) => ({
    ...childProps,
    component: propChildrenArray.find(({ key }) => key === childProps.component.key) || childProps.component,
    shouldRender: !!propChildKeyMap[childProps.component.key]
  }));
  return insertMethod === "append" ? updatedCurrentChildren.concat(newRenderChildren) : newRenderChildren.concat(updatedCurrentChildren);
}
function assertSingleChildWhenRef(componentName, ref, childrenCount) {
  if ((isTest || isDev) && ref && childrenCount > 1) {
    throw new Error(`Cannot use forwardRef with multiple children in <${componentName} />`);
  }
}

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
import s from "/Users/jamiecraik/dev/aStudio/node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.module.css";

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/transitionReducer.js
var RESTING_TRANSITION_STATE = {
  enter: false,
  enterActive: false,
  exit: false,
  exitActive: false,
  interrupted: false
};
var getInitialTransitionState = (preventMountTransition) => ({
  ...RESTING_TRANSITION_STATE,
  enter: !preventMountTransition
});
var transitionReducer = (state, action) => {
  switch (action.type) {
    case "enter-before":
      return {
        enter: true,
        enterActive: false,
        exit: false,
        exitActive: false,
        interrupted: state.interrupted || state.exit
      };
    case "enter-active":
      return {
        enter: true,
        enterActive: true,
        exit: false,
        exitActive: false,
        interrupted: false
      };
    case "exit-before":
      return {
        enter: false,
        enterActive: false,
        exit: true,
        exitActive: false,
        interrupted: state.interrupted || state.enter
      };
    case "exit-active":
      return {
        enter: false,
        enterActive: false,
        exit: true,
        exitActive: true,
        interrupted: false
      };
    case "done":
    default:
      return RESTING_TRANSITION_STATE;
  }
};

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
var TransitionGroupChildInner = ({ ref: forwardedRef, as: TagName, children, className, transitionId, style, preventMountTransition, shouldRender, enterDuration, exitDuration, removeChild, onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete }) => {
  const [state, dispatch] = (0, import_react3.useReducer)(transitionReducer, getInitialTransitionState(preventMountTransition || false));
  const preventedMountTransition = (0, import_react3.useRef)(false);
  const elementRef = (0, import_react3.useRef)(null);
  const enterDurationRef = (0, import_react3.useRef)(enterDuration);
  enterDurationRef.current = enterDuration;
  const exitDurationRef = (0, import_react3.useRef)(exitDuration);
  exitDurationRef.current = exitDuration;
  const lastCallbackRef = (0, import_react3.useRef)(null);
  const triggerCallback = (0, import_react3.useCallback)((callbackType) => {
    const element = elementRef.current;
    if (!element || callbackType === lastCallbackRef.current) {
      return;
    }
    lastCallbackRef.current = callbackType;
    switch (callbackType) {
      case "enter":
        onEnter(element);
        break;
      case "enter-active":
        onEnterActive(element);
        break;
      case "enter-complete":
        onEnterComplete(element);
        break;
      case "exit":
        onExit(element);
        break;
      case "exit-active":
        onExitActive(element);
        break;
      case "exit-complete":
        onExitComplete(element);
        break;
      default:
        callbackType;
        break;
    }
  }, [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  import_react3.default.useLayoutEffect(() => {
    if (!shouldRender) {
      let exitTimeout;
      dispatch({ type: "exit-before" });
      triggerCallback("exit");
      const cancelAnimationFrame2 = waitForAnimationFrame(() => {
        dispatch({ type: "exit-active" });
        triggerCallback("exit-active");
        exitTimeout = window.setTimeout(() => {
          triggerCallback("exit-complete");
          removeChild();
        }, exitDurationRef.current);
      });
      return () => {
        cancelAnimationFrame2();
        if (exitTimeout !== void 0)
          clearTimeout(exitTimeout);
      };
    }
    if (preventMountTransition && !preventedMountTransition.current) {
      preventedMountTransition.current = true;
      return;
    }
    let enterTimeout;
    dispatch({ type: "enter-before" });
    triggerCallback("enter");
    const cancelAnimationFrame = waitForAnimationFrame(() => {
      dispatch({ type: "enter-active" });
      triggerCallback("enter-active");
      enterTimeout = window.setTimeout(() => {
        dispatch({ type: "done" });
        triggerCallback("enter-complete");
      }, enterDurationRef.current);
    });
    return () => {
      cancelAnimationFrame();
      if (enterTimeout !== void 0)
        clearTimeout(enterTimeout);
    };
  }, [
    shouldRender,
    // This value is immutable after <TransitionGroup> is created, and does not change on re-renders.
    preventMountTransition,
    removeChild,
    triggerCallback
  ]);
  (0, import_react3.useEffect)(() => {
    return () => {
      preventedMountTransition.current = false;
    };
  }, []);
  return (0, import_jsx_runtime.jsx)(TagName, { ref: o([elementRef, forwardedRef]), className: clsx_default(className, s.TransitionGroupChild), "data-transition-id": transitionId, style, "data-entering": state.enter ? "" : void 0, "data-entering-active": state.enterActive ? "" : void 0, "data-exiting": state.exit ? "" : void 0, "data-exiting-active": state.exitActive ? "" : void 0, "data-interrupted": state.interrupted ? "" : void 0, children });
};
var TransitionGroupChild = (props) => {
  const { enterMountDelay, preventMountTransition } = props;
  const mountDelay = !preventMountTransition && enterMountDelay != null ? enterMountDelay : null;
  const [mounted, setMounted] = (0, import_react3.useState)(mountDelay == null);
  useTimeout(() => setMounted(true), mounted ? null : mountDelay);
  return mounted ? (0, import_jsx_runtime.jsx)(TransitionGroupChildInner, { ...props }) : null;
};
var TransitionGroup = (props) => {
  const { ref: forwardedRef, as: TagName = "span", children, className, transitionId, style, enterDuration = 0, exitDuration = 0, preventInitialTransition = true, enterMountDelay, insertMethod = "append", disableAnimations = getDisableAnimations_default() } = props;
  const onEnter = useChildCallback(props.onEnter ?? noop);
  const onEnterActive = useChildCallback(props.onEnterActive ?? noop);
  const onEnterComplete = useChildCallback(props.onEnterComplete ?? noop);
  const onExit = useChildCallback(props.onExit ?? noop);
  const onExitActive = useChildCallback(props.onExitActive ?? noop);
  const onExitComplete = useChildCallback(props.onExitComplete ?? noop);
  import_react3.Children.forEach(children, (child) => {
    if (child && !child.key) {
      throw new Error("Child elements of <TransitionGroup /> must include a `key`");
    }
  });
  const createDefaultRenderChildProps = (0, import_react3.useCallback)((child) => ({
    component: child,
    shouldRender: true,
    removeChild: () => {
      setRenderChildren((currentRenderChildren) => currentRenderChildren.filter((c) => child.key !== c.component.key));
    },
    onEnter,
    onEnterActive,
    onEnterComplete,
    onExit,
    onExitActive,
    onExitComplete
  }), [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  const [renderChildren, setRenderChildren] = (0, import_react3.useState)(() => {
    return ChildrenWithKeys(children).map((child) => ({
      ...createDefaultRenderChildProps(child),
      // Lock this value to whatever the value was on initial render of the TransitionGroup.
      // It doesn't make sense to change this once it is mounted.
      preventMountTransition: preventInitialTransition
    }));
  });
  (0, import_react3.useLayoutEffect)(() => {
    setRenderChildren((currentRenderChildren) => {
      const propChildrenArray = ChildrenWithKeys(children);
      return computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod);
    });
  }, [children, insertMethod, createDefaultRenderChildProps]);
  assertSingleChildWhenRef("TransitionGroup", forwardedRef, import_react3.Children.count(children));
  if (disableAnimations) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: import_react3.Children.map(children, (child) => (0, import_jsx_runtime.jsx)(
      TagName,
      {
        // @ts-expect-error -- TS is not happy about this forwardedRef, but it's fine.
        ref: forwardedRef,
        className,
        style,
        "data-transition-id": transitionId,
        children: child
      }
    )) });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: renderChildren.map(({ component, ...restProps }) => (0, import_jsx_runtime.jsx)(TransitionGroupChild, { ...restProps, as: TagName, className, transitionId, enterDuration, exitDuration, enterMountDelay, style, ref: forwardedRef, children: component }, component.key)) });
};

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/Animate.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());
import s2 from "/Users/jamiecraik/dev/aStudio/node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/Animate.module.css";
var Animate = (props) => {
  const { as: TagName = "span", className, children, preventInitialTransition, insertMethod, transitionClassName, transitionPosition = "absolute" } = props;
  const { enterTotalDuration, exitTotalDuration, variables } = getAnimationProperties(props);
  return (0, import_jsx_runtime2.jsx)(TagName, { className: clsx_default("block", transitionPosition === "absolute" && "relative", className), "data-transition-position": transitionPosition, style: variables, children: (0, import_jsx_runtime2.jsx)(TransitionGroup, { as: TagName, className: clsx_default(s2.TransitionItem, transitionClassName), enterDuration: enterTotalDuration, exitDuration: exitTotalDuration, insertMethod, preventInitialTransition, children }) });
};
var DEFAULT_ENTER_DURATION_MS_EASE = 400;
var DEFAULT_ENTER_DURATION_MS_CUBIC = 500;
var DEFAULT_EXIT_DURATION_MS_EASE = 200;
var DEFAULT_EXIT_DURATION_MS_CUBIC = 300;
function getAnimationProperties({ initial, enter, exit, forceCompositeLayer }) {
  const initialTransform = toTransformProperty(initial);
  const enterTransform = toTransformProperty(enter);
  const exitTransform = toTransformProperty(exit);
  const isCubicTransition = [initialTransform, exitTransform, enterTransform].some((t) => t !== "none");
  const enterDuration = enter?.duration ?? (isCubicTransition ? DEFAULT_ENTER_DURATION_MS_CUBIC : DEFAULT_ENTER_DURATION_MS_EASE);
  const enterTimingFunction = enter?.timingFunction ?? (isCubicTransition ? "var(--cubic-enter)" : "ease");
  const exitDuration = exit?.duration ?? (isCubicTransition ? DEFAULT_EXIT_DURATION_MS_CUBIC : DEFAULT_EXIT_DURATION_MS_EASE);
  const exitTimingFunction = exit?.timingFunction ?? (isCubicTransition ? "var(--cubic-exit)" : "ease");
  const variables = toCssVariables({
    "tg-will-change": forceCompositeLayer ? "transform, opacity" : "auto",
    "tg-enter-opacity": toOpacityProperty(enter?.opacity ?? 1),
    "tg-enter-transform": enterTransform,
    "tg-enter-filter": toFilterProperty(enter),
    "tg-enter-duration": toMsDurationProperty(enterDuration),
    "tg-enter-delay": toMsDurationProperty(enter?.delay ?? 0),
    "tg-enter-timing-function": enterTimingFunction,
    "tg-exit-opacity": toOpacityProperty(exit?.opacity ?? 0),
    "tg-exit-transform": exitTransform,
    "tg-exit-filter": toFilterProperty(exit),
    "tg-exit-duration": toMsDurationProperty(exitDuration),
    "tg-exit-delay": toMsDurationProperty(exit?.delay ?? 0),
    "tg-exit-timing-function": exitTimingFunction,
    "tg-initial-opacity": toOpacityProperty(initial?.opacity ?? exit?.opacity ?? 0),
    "tg-initial-transform": initialTransform === "none" ? exitTransform : initialTransform,
    "tg-initial-filter": toFilterProperty(initial ?? exit ?? {})
  });
  const enterTotalDuration = (enter?.delay ?? 0) + enterDuration;
  const exitTotalDuration = (exit?.delay ?? 0) + exitDuration;
  return { enterTotalDuration, exitTotalDuration, variables };
}

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayout.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react5 = __toESM(require_react());
import s3 from "/Users/jamiecraik/dev/aStudio/node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayout.module.css";

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayoutGroup.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());
import s4 from "/Users/jamiecraik/dev/aStudio/node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayoutGroup.module.css";

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/SlotTransitionGroup.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react7 = __toESM(require_react());

export {
  useTimeout,
  TransitionGroup,
  Animate
};
//# sourceMappingURL=chunk-QFBUIEQY.js.map
