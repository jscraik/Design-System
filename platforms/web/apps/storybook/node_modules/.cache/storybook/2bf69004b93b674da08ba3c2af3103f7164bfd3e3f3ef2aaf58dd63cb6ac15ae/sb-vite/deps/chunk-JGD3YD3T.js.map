{
  "version": 3,
  "sources": ["../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-accessible-icon@1.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@typ_a7d1f5c00e60c7f0dfaeb3577cf28ac7/node_modules/@radix-ui/react-accessible-icon/src/accessible-icon.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-aspect-ratio@1.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@types+_37e7976ef844ad6d1abf521692b00d11/node_modules/@radix-ui/react-aspect-ratio/src/aspect-ratio.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-avatar@1.1.10_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react_91583c912c1509308a599bb2f3bf3c1b/node_modules/@radix-ui/react-avatar/src/avatar.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-form@0.1.8_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19_7256a4266a2d3a89aebb0537251a54a0/node_modules/@radix-ui/react-form/src/form.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-label@2.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@1_2fd8c22a5f14bfe0ea62c1d5a2aa946f/node_modules/@radix-ui/react-label/src/label.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-one-time-password-field@0.1.8_@types+react-dom@19.2.3_@types+react@19.2_1c5d81024dbbd3e9b72741362c2d04aa/node_modules/@radix-ui/react-one-time-password-field/src/one-time-password-field.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-password-toggle-field@0.1.3_@types+react-dom@19.2.3_@types+react@19.2.7_aa474132162a3508900a3ac3501d2510/node_modules/@radix-ui/react-password-toggle-field/src/password-toggle-field.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-progress@1.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@types+reac_d7e75eaa5845b0a94d304de74b4449e8/node_modules/@radix-ui/react-progress/src/progress.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-separator@1.1.7_@types+react-dom@19.2.3_@types+react@19.2.7__@types+rea_818a57bdd4abcca6a4c8e2b7f8897216/node_modules/@radix-ui/react-separator/src/separator.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-toast@1.2.15_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@_7d5f443bd8b46aff00f2d3dd88d38e09/node_modules/@radix-ui/react-toast/src/toast.tsx", "../../../../../../../../../../node_modules/.pnpm/@radix-ui+react-toolbar@1.1.11_@types+react-dom@19.2.3_@types+react@19.2.7__@types+reac_07b8a711f36eab71d085f86a9f38f525/node_modules/@radix-ui/react-toolbar/src/toolbar.tsx"],
  "sourcesContent": ["import * as React from 'react';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\n\nconst NAME = 'AccessibleIcon';\n\ninterface AccessibleIconProps {\n  children?: React.ReactNode;\n  /**\n   * The accessible label for the icon. This label will be visually hidden but announced to screen\n   * reader users, similar to `alt` text for `img` tags.\n   */\n  label: string;\n}\n\nconst AccessibleIcon: React.FC<AccessibleIconProps> = ({ children, label }) => {\n  const child = React.Children.only(children);\n  return (\n    <>\n      {React.cloneElement(child as React.ReactElement<React.SVGAttributes<SVGElement>>, {\n        // accessibility\n        'aria-hidden': 'true',\n        focusable: 'false', // See: https://allyjs.io/tutorials/focusing-in-svg.html#making-svg-elements-focusable\n      })}\n      <VisuallyHiddenPrimitive.Root>{label}</VisuallyHiddenPrimitive.Root>\n    </>\n  );\n};\n\nAccessibleIcon.displayName = NAME;\n\nconst Root = AccessibleIcon;\n\nexport {\n  AccessibleIcon,\n  //\n  Root,\n};\nexport type { AccessibleIconProps };\n", "import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * AspectRatio\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'AspectRatio';\n\ntype AspectRatioElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface AspectRatioProps extends PrimitiveDivProps {\n  ratio?: number;\n}\n\nconst AspectRatio = React.forwardRef<AspectRatioElement, AspectRatioProps>(\n  (props, forwardedRef) => {\n    const { ratio = 1 / 1, style, ...aspectRatioProps } = props;\n    return (\n      <div\n        style={{\n          // ensures inner element is contained\n          position: 'relative',\n          // ensures padding bottom trick maths works\n          width: '100%',\n          paddingBottom: `${100 / ratio}%`,\n        }}\n        data-radix-aspect-ratio-wrapper=\"\"\n      >\n        <Primitive.div\n          {...aspectRatioProps}\n          ref={forwardedRef}\n          style={{\n            ...style,\n            // ensures children expand in ratio\n            position: 'absolute',\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n          }}\n        />\n      </div>\n    );\n  }\n);\n\nAspectRatio.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = AspectRatio;\n\nexport {\n  AspectRatio,\n  //\n  Root,\n};\nexport type { AspectRatioProps };\n", "import * as React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useIsHydrated } from '@radix-ui/react-use-is-hydrated';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Avatar\n * -----------------------------------------------------------------------------------------------*/\n\nconst AVATAR_NAME = 'Avatar';\n\ntype ScopedProps<P> = P & { __scopeAvatar?: Scope };\nconst [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);\n\ntype ImageLoadingStatus = 'idle' | 'loading' | 'loaded' | 'error';\n\ntype AvatarContextValue = {\n  imageLoadingStatus: ImageLoadingStatus;\n  onImageLoadingStatusChange(status: ImageLoadingStatus): void;\n};\n\nconst [AvatarProvider, useAvatarContext] = createAvatarContext<AvatarContextValue>(AVATAR_NAME);\n\ntype AvatarElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface AvatarProps extends PrimitiveSpanProps {}\n\nconst Avatar = React.forwardRef<AvatarElement, AvatarProps>(\n  (props: ScopedProps<AvatarProps>, forwardedRef) => {\n    const { __scopeAvatar, ...avatarProps } = props;\n    const [imageLoadingStatus, setImageLoadingStatus] = React.useState<ImageLoadingStatus>('idle');\n    return (\n      <AvatarProvider\n        scope={__scopeAvatar}\n        imageLoadingStatus={imageLoadingStatus}\n        onImageLoadingStatusChange={setImageLoadingStatus}\n      >\n        <Primitive.span {...avatarProps} ref={forwardedRef} />\n      </AvatarProvider>\n    );\n  }\n);\n\nAvatar.displayName = AVATAR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * AvatarImage\n * -----------------------------------------------------------------------------------------------*/\n\nconst IMAGE_NAME = 'AvatarImage';\n\ntype AvatarImageElement = React.ComponentRef<typeof Primitive.img>;\ntype PrimitiveImageProps = React.ComponentPropsWithoutRef<typeof Primitive.img>;\ninterface AvatarImageProps extends PrimitiveImageProps {\n  onLoadingStatusChange?: (status: ImageLoadingStatus) => void;\n}\n\nconst AvatarImage = React.forwardRef<AvatarImageElement, AvatarImageProps>(\n  (props: ScopedProps<AvatarImageProps>, forwardedRef) => {\n    const { __scopeAvatar, src, onLoadingStatusChange = () => {}, ...imageProps } = props;\n    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);\n    const imageLoadingStatus = useImageLoadingStatus(src, imageProps);\n    const handleLoadingStatusChange = useCallbackRef((status: ImageLoadingStatus) => {\n      onLoadingStatusChange(status);\n      context.onImageLoadingStatusChange(status);\n    });\n\n    useLayoutEffect(() => {\n      if (imageLoadingStatus !== 'idle') {\n        handleLoadingStatusChange(imageLoadingStatus);\n      }\n    }, [imageLoadingStatus, handleLoadingStatusChange]);\n\n    return imageLoadingStatus === 'loaded' ? (\n      <Primitive.img {...imageProps} ref={forwardedRef} src={src} />\n    ) : null;\n  }\n);\n\nAvatarImage.displayName = IMAGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * AvatarFallback\n * -----------------------------------------------------------------------------------------------*/\n\nconst FALLBACK_NAME = 'AvatarFallback';\n\ntype AvatarFallbackElement = React.ComponentRef<typeof Primitive.span>;\ninterface AvatarFallbackProps extends PrimitiveSpanProps {\n  delayMs?: number;\n}\n\nconst AvatarFallback = React.forwardRef<AvatarFallbackElement, AvatarFallbackProps>(\n  (props: ScopedProps<AvatarFallbackProps>, forwardedRef) => {\n    const { __scopeAvatar, delayMs, ...fallbackProps } = props;\n    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);\n    const [canRender, setCanRender] = React.useState(delayMs === undefined);\n\n    React.useEffect(() => {\n      if (delayMs !== undefined) {\n        const timerId = window.setTimeout(() => setCanRender(true), delayMs);\n        return () => window.clearTimeout(timerId);\n      }\n    }, [delayMs]);\n\n    return canRender && context.imageLoadingStatus !== 'loaded' ? (\n      <Primitive.span {...fallbackProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nAvatarFallback.displayName = FALLBACK_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction resolveLoadingStatus(image: HTMLImageElement | null, src?: string): ImageLoadingStatus {\n  if (!image) {\n    return 'idle';\n  }\n  if (!src) {\n    return 'error';\n  }\n  if (image.src !== src) {\n    image.src = src;\n  }\n  return image.complete && image.naturalWidth > 0 ? 'loaded' : 'loading';\n}\n\nfunction useImageLoadingStatus(\n  src: string | undefined,\n  { referrerPolicy, crossOrigin }: AvatarImageProps\n) {\n  const isHydrated = useIsHydrated();\n  const imageRef = React.useRef<HTMLImageElement | null>(null);\n  const image = (() => {\n    if (!isHydrated) return null;\n    if (!imageRef.current) {\n      imageRef.current = new window.Image();\n    }\n    return imageRef.current;\n  })();\n\n  const [loadingStatus, setLoadingStatus] = React.useState<ImageLoadingStatus>(() =>\n    resolveLoadingStatus(image, src)\n  );\n\n  useLayoutEffect(() => {\n    setLoadingStatus(resolveLoadingStatus(image, src));\n  }, [image, src]);\n\n  useLayoutEffect(() => {\n    const updateStatus = (status: ImageLoadingStatus) => () => {\n      setLoadingStatus(status);\n    };\n\n    if (!image) return;\n\n    const handleLoad = updateStatus('loaded');\n    const handleError = updateStatus('error');\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n    if (referrerPolicy) {\n      image.referrerPolicy = referrerPolicy;\n    }\n    if (typeof crossOrigin === 'string') {\n      image.crossOrigin = crossOrigin;\n    }\n\n    return () => {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    };\n  }, [image, crossOrigin, referrerPolicy]);\n\n  return loadingStatus;\n}\n\nconst Root = Avatar;\nconst Image = AvatarImage;\nconst Fallback = AvatarFallback;\n\nexport {\n  createAvatarScope,\n  //\n  Avatar,\n  AvatarImage,\n  AvatarFallback,\n  //\n  Root,\n  Image,\n  Fallback,\n};\nexport type { AvatarProps, AvatarImageProps, AvatarFallbackProps };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Label as LabelPrimitive } from '@radix-ui/react-label';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype ScopedProps<P> = P & { __scopeForm?: Scope };\nconst [createFormContext, createFormScope] = createContextScope('Form');\n\n/* -------------------------------------------------------------------------------------------------\n * Form\n * -----------------------------------------------------------------------------------------------*/\n\nconst FORM_NAME = 'Form';\n\ntype ValidityMap = { [fieldName: string]: ValidityState | undefined };\ntype CustomMatcherEntriesMap = { [fieldName: string]: CustomMatcherEntry[] };\ntype CustomErrorsMap = { [fieldName: string]: Record<string, boolean> };\n\ntype ValidationContextValue = {\n  getFieldValidity(fieldName: string): ValidityState | undefined;\n  onFieldValidityChange(fieldName: string, validity: ValidityState): void;\n\n  getFieldCustomMatcherEntries(fieldName: string): CustomMatcherEntry[];\n  onFieldCustomMatcherEntryAdd(fieldName: string, matcherEntry: CustomMatcherEntry): void;\n  onFieldCustomMatcherEntryRemove(fieldName: string, matcherEntryId: string): void;\n\n  getFieldCustomErrors(fieldName: string): Record<string, boolean>;\n  onFieldCustomErrorsChange(fieldName: string, errors: Record<string, boolean>): void;\n\n  onFieldValiditionClear(fieldName: string): void;\n};\nconst [ValidationProvider, useValidationContext] =\n  createFormContext<ValidationContextValue>(FORM_NAME);\n\ntype MessageIdsMap = { [fieldName: string]: Set<string> };\n\ntype AriaDescriptionContextValue = {\n  onFieldMessageIdAdd(fieldName: string, id: string): void;\n  onFieldMessageIdRemove(fieldName: string, id: string): void;\n  getFieldDescription(fieldName: string): string | undefined;\n};\nconst [AriaDescriptionProvider, useAriaDescriptionContext] =\n  createFormContext<AriaDescriptionContextValue>(FORM_NAME);\n\ntype FormElement = React.ComponentRef<typeof Primitive.form>;\ntype PrimitiveFormProps = React.ComponentPropsWithoutRef<typeof Primitive.form>;\ninterface FormProps extends PrimitiveFormProps {\n  onClearServerErrors?(): void;\n}\n\nconst Form = React.forwardRef<FormElement, FormProps>(\n  (props: ScopedProps<FormProps>, forwardedRef) => {\n    const { __scopeForm, onClearServerErrors = () => {}, ...rootProps } = props;\n    const formRef = React.useRef<HTMLFormElement>(null);\n    const composedFormRef = useComposedRefs(forwardedRef, formRef);\n\n    // native validity per field\n    const [validityMap, setValidityMap] = React.useState<ValidityMap>({});\n    const getFieldValidity: ValidationContextValue['getFieldValidity'] = React.useCallback(\n      (fieldName) => validityMap[fieldName],\n      [validityMap]\n    );\n    const handleFieldValidityChange: ValidationContextValue['onFieldValidityChange'] =\n      React.useCallback(\n        (fieldName, validity) =>\n          setValidityMap((prevValidityMap) => ({\n            ...prevValidityMap,\n            [fieldName]: { ...(prevValidityMap[fieldName] ?? {}), ...validity },\n          })),\n        []\n      );\n    const handleFieldValiditionClear: ValidationContextValue['onFieldValiditionClear'] =\n      React.useCallback((fieldName) => {\n        setValidityMap((prevValidityMap) => ({ ...prevValidityMap, [fieldName]: undefined }));\n        setCustomErrorsMap((prevCustomErrorsMap) => ({ ...prevCustomErrorsMap, [fieldName]: {} }));\n      }, []);\n\n    // custom matcher entries per field\n    const [customMatcherEntriesMap, setCustomMatcherEntriesMap] =\n      React.useState<CustomMatcherEntriesMap>({});\n    const getFieldCustomMatcherEntries: ValidationContextValue['getFieldCustomMatcherEntries'] =\n      React.useCallback(\n        (fieldName) => customMatcherEntriesMap[fieldName] ?? [],\n        [customMatcherEntriesMap]\n      );\n    const handleFieldCustomMatcherAdd: ValidationContextValue['onFieldCustomMatcherEntryAdd'] =\n      React.useCallback((fieldName, matcherEntry) => {\n        setCustomMatcherEntriesMap((prevCustomMatcherEntriesMap) => ({\n          ...prevCustomMatcherEntriesMap,\n          [fieldName]: [...(prevCustomMatcherEntriesMap[fieldName] ?? []), matcherEntry],\n        }));\n      }, []);\n    const handleFieldCustomMatcherRemove: ValidationContextValue['onFieldCustomMatcherEntryRemove'] =\n      React.useCallback((fieldName, matcherEntryId) => {\n        setCustomMatcherEntriesMap((prevCustomMatcherEntriesMap) => ({\n          ...prevCustomMatcherEntriesMap,\n          [fieldName]: (prevCustomMatcherEntriesMap[fieldName] ?? []).filter(\n            (matcherEntry) => matcherEntry.id !== matcherEntryId\n          ),\n        }));\n      }, []);\n\n    // custom errors per field\n    const [customErrorsMap, setCustomErrorsMap] = React.useState<CustomErrorsMap>({});\n    const getFieldCustomErrors: ValidationContextValue['getFieldCustomErrors'] = React.useCallback(\n      (fieldName) => customErrorsMap[fieldName] ?? {},\n      [customErrorsMap]\n    );\n    const handleFieldCustomErrorsChange: ValidationContextValue['onFieldCustomErrorsChange'] =\n      React.useCallback((fieldName, customErrors) => {\n        setCustomErrorsMap((prevCustomErrorsMap) => ({\n          ...prevCustomErrorsMap,\n          [fieldName]: { ...(prevCustomErrorsMap[fieldName] ?? {}), ...customErrors },\n        }));\n      }, []);\n\n    // messageIds per field\n    const [messageIdsMap, setMessageIdsMap] = React.useState<MessageIdsMap>({});\n    const handleFieldMessageIdAdd: AriaDescriptionContextValue['onFieldMessageIdAdd'] =\n      React.useCallback((fieldName, id) => {\n        setMessageIdsMap((prevMessageIdsMap) => {\n          const fieldDescriptionIds = new Set(prevMessageIdsMap[fieldName]).add(id);\n          return { ...prevMessageIdsMap, [fieldName]: fieldDescriptionIds };\n        });\n      }, []);\n    const handleFieldMessageIdRemove: AriaDescriptionContextValue['onFieldMessageIdRemove'] =\n      React.useCallback((fieldName, id) => {\n        setMessageIdsMap((prevMessageIdsMap) => {\n          const fieldDescriptionIds = new Set(prevMessageIdsMap[fieldName]);\n          fieldDescriptionIds.delete(id);\n          return { ...prevMessageIdsMap, [fieldName]: fieldDescriptionIds };\n        });\n      }, []);\n    const getFieldDescription: AriaDescriptionContextValue['getFieldDescription'] =\n      React.useCallback(\n        (fieldName) => Array.from(messageIdsMap[fieldName] ?? []).join(' ') || undefined,\n        [messageIdsMap]\n      );\n\n    return (\n      <ValidationProvider\n        scope={__scopeForm}\n        getFieldValidity={getFieldValidity}\n        onFieldValidityChange={handleFieldValidityChange}\n        getFieldCustomMatcherEntries={getFieldCustomMatcherEntries}\n        onFieldCustomMatcherEntryAdd={handleFieldCustomMatcherAdd}\n        onFieldCustomMatcherEntryRemove={handleFieldCustomMatcherRemove}\n        getFieldCustomErrors={getFieldCustomErrors}\n        onFieldCustomErrorsChange={handleFieldCustomErrorsChange}\n        onFieldValiditionClear={handleFieldValiditionClear}\n      >\n        <AriaDescriptionProvider\n          scope={__scopeForm}\n          onFieldMessageIdAdd={handleFieldMessageIdAdd}\n          onFieldMessageIdRemove={handleFieldMessageIdRemove}\n          getFieldDescription={getFieldDescription}\n        >\n          <Primitive.form\n            {...rootProps}\n            ref={composedFormRef}\n            // focus first invalid control when the form is submitted\n            onInvalid={composeEventHandlers(props.onInvalid, (event) => {\n              const firstInvalidControl = getFirstInvalidControl(event.currentTarget);\n              if (firstInvalidControl === event.target) firstInvalidControl.focus();\n\n              // prevent default browser UI for form validation\n              event.preventDefault();\n            })}\n            // clear server errors when the form is re-submitted\n            onSubmit={composeEventHandlers(props.onSubmit, onClearServerErrors, {\n              checkForDefaultPrevented: false,\n            })}\n            // clear server errors when the form is reset\n            onReset={composeEventHandlers(props.onReset, onClearServerErrors)}\n          />\n        </AriaDescriptionProvider>\n      </ValidationProvider>\n    );\n  }\n);\n\nForm.displayName = FORM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * FormField\n * -----------------------------------------------------------------------------------------------*/\n\nconst FIELD_NAME = 'FormField';\n\ntype FormFieldContextValue = {\n  id: string;\n  name: string;\n  serverInvalid: boolean;\n};\nconst [FormFieldProvider, useFormFieldContext] =\n  createFormContext<FormFieldContextValue>(FIELD_NAME);\n\ntype FormFieldElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FormFieldProps extends PrimitiveDivProps {\n  name: string;\n  serverInvalid?: boolean;\n}\n\nconst FormField = React.forwardRef<FormFieldElement, FormFieldProps>(\n  (props: ScopedProps<FormFieldProps>, forwardedRef) => {\n    const { __scopeForm, name, serverInvalid = false, ...fieldProps } = props;\n    const validationContext = useValidationContext(FIELD_NAME, __scopeForm);\n    const validity = validationContext.getFieldValidity(name);\n    const id = useId();\n\n    return (\n      <FormFieldProvider scope={__scopeForm} id={id} name={name} serverInvalid={serverInvalid}>\n        <Primitive.div\n          data-valid={getValidAttribute(validity, serverInvalid)}\n          data-invalid={getInvalidAttribute(validity, serverInvalid)}\n          {...fieldProps}\n          ref={forwardedRef}\n        />\n      </FormFieldProvider>\n    );\n  }\n);\n\nFormField.displayName = FIELD_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * FormLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'FormLabel';\n\ntype FormLabelElement = React.ComponentRef<typeof LabelPrimitive>;\ntype LabelProps = React.ComponentPropsWithoutRef<typeof LabelPrimitive>;\ninterface FormLabelProps extends LabelProps {}\n\nconst FormLabel = React.forwardRef<FormLabelElement, FormLabelProps>(\n  (props: ScopedProps<FormLabelProps>, forwardedRef) => {\n    const { __scopeForm, ...labelProps } = props;\n    const validationContext = useValidationContext(LABEL_NAME, __scopeForm);\n    const fieldContext = useFormFieldContext(LABEL_NAME, __scopeForm);\n    const htmlFor = labelProps.htmlFor || fieldContext.id;\n    const validity = validationContext.getFieldValidity(fieldContext.name);\n\n    return (\n      <LabelPrimitive\n        data-valid={getValidAttribute(validity, fieldContext.serverInvalid)}\n        data-invalid={getInvalidAttribute(validity, fieldContext.serverInvalid)}\n        {...labelProps}\n        ref={forwardedRef}\n        htmlFor={htmlFor}\n      />\n    );\n  }\n);\n\nFormLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * FormControl\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTROL_NAME = 'FormControl';\n\ntype FormControlElement = React.ComponentRef<typeof Primitive.input>;\ntype PrimitiveInputProps = React.ComponentPropsWithoutRef<typeof Primitive.input>;\ninterface FormControlProps extends PrimitiveInputProps {}\n\nconst FormControl = React.forwardRef<FormControlElement, FormControlProps>(\n  (props: ScopedProps<FormControlProps>, forwardedRef) => {\n    const { __scopeForm, ...controlProps } = props;\n\n    const validationContext = useValidationContext(CONTROL_NAME, __scopeForm);\n    const fieldContext = useFormFieldContext(CONTROL_NAME, __scopeForm);\n    const ariaDescriptionContext = useAriaDescriptionContext(CONTROL_NAME, __scopeForm);\n\n    const ref = React.useRef<FormControlElement>(null);\n    const composedRef = useComposedRefs(forwardedRef, ref);\n    const name = controlProps.name || fieldContext.name;\n    const id = controlProps.id || fieldContext.id;\n    const customMatcherEntries = validationContext.getFieldCustomMatcherEntries(name);\n\n    const { onFieldValidityChange, onFieldCustomErrorsChange, onFieldValiditionClear } =\n      validationContext;\n    const updateControlValidity = React.useCallback(\n      async (control: FormControlElement) => {\n        //------------------------------------------------------------------------------------------\n        // 1. first, if we have built-in errors we stop here\n\n        if (hasBuiltInError(control.validity)) {\n          const controlValidity = validityStateToObject(control.validity);\n          onFieldValidityChange(name, controlValidity);\n          return;\n        }\n\n        //------------------------------------------------------------------------------------------\n        // 2. then gather the form data to give to custom matchers for cross-comparisons\n\n        const formData = control.form ? new FormData(control.form) : new FormData();\n        const matcherArgs: CustomMatcherArgs = [control.value, formData];\n\n        //------------------------------------------------------------------------------------------\n        // 3. split sync and async custom matcher entries\n\n        const syncCustomMatcherEntries: Array<SyncCustomMatcherEntry> = [];\n        const ayncCustomMatcherEntries: Array<AsyncCustomMatcherEntry> = [];\n        customMatcherEntries.forEach((customMatcherEntry) => {\n          if (isAsyncCustomMatcherEntry(customMatcherEntry, matcherArgs)) {\n            ayncCustomMatcherEntries.push(customMatcherEntry);\n          } else if (isSyncCustomMatcherEntry(customMatcherEntry)) {\n            syncCustomMatcherEntries.push(customMatcherEntry);\n          }\n        });\n\n        //------------------------------------------------------------------------------------------\n        // 4. run sync custom matchers and update control validity / internal validity + errors\n\n        const syncCustomErrors = syncCustomMatcherEntries.map(({ id, match }) => {\n          return [id, match(...matcherArgs)] as const;\n        });\n        const syncCustomErrorsById = Object.fromEntries(syncCustomErrors);\n        const hasSyncCustomErrors = Object.values(syncCustomErrorsById).some(Boolean);\n        const hasCustomError = hasSyncCustomErrors;\n        control.setCustomValidity(hasCustomError ? DEFAULT_INVALID_MESSAGE : '');\n        const controlValidity = validityStateToObject(control.validity);\n        onFieldValidityChange(name, controlValidity);\n        onFieldCustomErrorsChange(name, syncCustomErrorsById);\n\n        //------------------------------------------------------------------------------------------\n        // 5. run async custom matchers and update control validity / internal validity + errors\n\n        if (!hasSyncCustomErrors && ayncCustomMatcherEntries.length > 0) {\n          const promisedCustomErrors = ayncCustomMatcherEntries.map(({ id, match }) =>\n            match(...matcherArgs).then((matches) => [id, matches] as const)\n          );\n          const asyncCustomErrors = await Promise.all(promisedCustomErrors);\n          const asyncCustomErrorsById = Object.fromEntries(asyncCustomErrors);\n          const hasAsyncCustomErrors = Object.values(asyncCustomErrorsById).some(Boolean);\n          const hasCustomError = hasAsyncCustomErrors;\n          control.setCustomValidity(hasCustomError ? DEFAULT_INVALID_MESSAGE : '');\n          const controlValidity = validityStateToObject(control.validity);\n          onFieldValidityChange(name, controlValidity);\n          onFieldCustomErrorsChange(name, asyncCustomErrorsById);\n        }\n      },\n      [customMatcherEntries, name, onFieldCustomErrorsChange, onFieldValidityChange]\n    );\n\n    React.useEffect(() => {\n      const control = ref.current;\n      if (control) {\n        // We only want validate on change (native `change` event, not React's `onChange`). This is primarily\n        // a UX decision, we don't want to validate on every keystroke and React's `onChange` is the `input` event.\n        const handleChange = () => updateControlValidity(control);\n        control.addEventListener('change', handleChange);\n        return () => control.removeEventListener('change', handleChange);\n      }\n    }, [updateControlValidity]);\n\n    const resetControlValidity = React.useCallback(() => {\n      const control = ref.current;\n      if (control) {\n        control.setCustomValidity('');\n        onFieldValiditionClear(name);\n      }\n    }, [name, onFieldValiditionClear]);\n\n    // reset validity and errors when the form is reset\n    React.useEffect(() => {\n      const form = ref.current?.form;\n      if (form) {\n        form.addEventListener('reset', resetControlValidity);\n        return () => form.removeEventListener('reset', resetControlValidity);\n      }\n    }, [resetControlValidity]);\n\n    // focus first invalid control when fields are set as invalid by server\n    React.useEffect(() => {\n      const control = ref.current;\n      const form = control?.closest('form');\n      if (form && fieldContext.serverInvalid) {\n        const firstInvalidControl = getFirstInvalidControl(form);\n        if (firstInvalidControl === control) firstInvalidControl.focus();\n      }\n    }, [fieldContext.serverInvalid]);\n\n    const validity = validationContext.getFieldValidity(name);\n\n    return (\n      <Primitive.input\n        data-valid={getValidAttribute(validity, fieldContext.serverInvalid)}\n        data-invalid={getInvalidAttribute(validity, fieldContext.serverInvalid)}\n        aria-invalid={fieldContext.serverInvalid ? true : undefined}\n        aria-describedby={ariaDescriptionContext.getFieldDescription(name)}\n        // disable default browser behaviour of showing built-in error message on hover\n        title=\"\"\n        {...controlProps}\n        ref={composedRef}\n        id={id}\n        name={name}\n        onInvalid={composeEventHandlers(props.onInvalid, (event) => {\n          const control = event.currentTarget;\n          updateControlValidity(control);\n        })}\n        onChange={composeEventHandlers(props.onChange, (_event) => {\n          // reset validity when user changes value\n          resetControlValidity();\n        })}\n      />\n    );\n  }\n);\n\nFormControl.displayName = CONTROL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * FormMessage\n * -----------------------------------------------------------------------------------------------*/\n\nconst _validityMatchers = [\n  'badInput',\n  'patternMismatch',\n  'rangeOverflow',\n  'rangeUnderflow',\n  'stepMismatch',\n  'tooLong',\n  'tooShort',\n  'typeMismatch',\n  'valid',\n  'valueMissing',\n] as const;\ntype ValidityMatcher = (typeof _validityMatchers)[number];\n\nconst DEFAULT_INVALID_MESSAGE = 'This value is not valid';\nconst DEFAULT_BUILT_IN_MESSAGES: Record<ValidityMatcher, string | undefined> = {\n  badInput: DEFAULT_INVALID_MESSAGE,\n  patternMismatch: 'This value does not match the required pattern',\n  rangeOverflow: 'This value is too large',\n  rangeUnderflow: 'This value is too small',\n  stepMismatch: 'This value does not match the required step',\n  tooLong: 'This value is too long',\n  tooShort: 'This value is too short',\n  typeMismatch: 'This value does not match the required type',\n  valid: undefined,\n  valueMissing: 'This value is missing',\n};\n\nconst MESSAGE_NAME = 'FormMessage';\n\ntype FormMessageElement = FormMessageImplElement;\ninterface FormMessageProps extends Omit<FormMessageImplProps, 'name'> {\n  match?: ValidityMatcher | CustomMatcher;\n  forceMatch?: boolean;\n  name?: string;\n}\n\nconst FormMessage = React.forwardRef<FormMessageElement, FormMessageProps>(\n  (props: ScopedProps<FormMessageProps>, forwardedRef) => {\n    const { match, name: nameProp, ...messageProps } = props;\n    const fieldContext = useFormFieldContext(MESSAGE_NAME, props.__scopeForm);\n    const name = nameProp ?? fieldContext.name;\n\n    if (match === undefined) {\n      return (\n        <FormMessageImpl {...messageProps} ref={forwardedRef} name={name}>\n          {props.children || DEFAULT_INVALID_MESSAGE}\n        </FormMessageImpl>\n      );\n    } else if (typeof match === 'function') {\n      return <FormCustomMessage match={match} {...messageProps} ref={forwardedRef} name={name} />;\n    } else {\n      return <FormBuiltInMessage match={match} {...messageProps} ref={forwardedRef} name={name} />;\n    }\n  }\n);\n\nFormMessage.displayName = MESSAGE_NAME;\n\ntype FormBuiltInMessageElement = FormMessageImplElement;\ninterface FormBuiltInMessageProps extends FormMessageImplProps {\n  match: ValidityMatcher;\n  forceMatch?: boolean;\n  name: string;\n}\n\nconst FormBuiltInMessage = React.forwardRef<FormBuiltInMessageElement, FormBuiltInMessageProps>(\n  (props: ScopedProps<FormBuiltInMessageProps>, forwardedRef) => {\n    const { match, forceMatch = false, name, children, ...messageProps } = props;\n    const validationContext = useValidationContext(MESSAGE_NAME, messageProps.__scopeForm);\n    const validity = validationContext.getFieldValidity(name);\n    const matches = forceMatch || validity?.[match];\n\n    if (matches) {\n      return (\n        <FormMessageImpl ref={forwardedRef} {...messageProps} name={name}>\n          {children ?? DEFAULT_BUILT_IN_MESSAGES[match]}\n        </FormMessageImpl>\n      );\n    }\n\n    return null;\n  }\n);\n\ntype FormCustomMessageElement = React.ComponentRef<typeof FormMessageImpl>;\ninterface FormCustomMessageProps extends React.ComponentPropsWithoutRef<typeof FormMessageImpl> {\n  match: CustomMatcher;\n  forceMatch?: boolean;\n  name: string;\n}\n\nconst FormCustomMessage = React.forwardRef<FormCustomMessageElement, FormCustomMessageProps>(\n  (props: ScopedProps<FormCustomMessageProps>, forwardedRef) => {\n    const { match, forceMatch = false, name, id: idProp, children, ...messageProps } = props;\n    const validationContext = useValidationContext(MESSAGE_NAME, messageProps.__scopeForm);\n    const ref = React.useRef<FormCustomMessageElement>(null);\n    const composedRef = useComposedRefs(forwardedRef, ref);\n    const _id = useId();\n    const id = idProp ?? _id;\n\n    const customMatcherEntry = React.useMemo(() => ({ id, match }), [id, match]);\n    const { onFieldCustomMatcherEntryAdd, onFieldCustomMatcherEntryRemove } = validationContext;\n    React.useEffect(() => {\n      onFieldCustomMatcherEntryAdd(name, customMatcherEntry);\n      return () => onFieldCustomMatcherEntryRemove(name, customMatcherEntry.id);\n    }, [customMatcherEntry, name, onFieldCustomMatcherEntryAdd, onFieldCustomMatcherEntryRemove]);\n\n    const validity = validationContext.getFieldValidity(name);\n    const customErrors = validationContext.getFieldCustomErrors(name);\n    const hasMatchingCustomError = customErrors[id];\n    const matches =\n      forceMatch || (validity && !hasBuiltInError(validity) && hasMatchingCustomError);\n\n    if (matches) {\n      return (\n        <FormMessageImpl id={id} ref={composedRef} {...messageProps} name={name}>\n          {children ?? DEFAULT_INVALID_MESSAGE}\n        </FormMessageImpl>\n      );\n    }\n\n    return null;\n  }\n);\n\ntype FormMessageImplElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface FormMessageImplProps extends PrimitiveSpanProps {\n  name: string;\n}\n\nconst FormMessageImpl = React.forwardRef<FormMessageImplElement, FormMessageImplProps>(\n  (props: ScopedProps<FormMessageImplProps>, forwardedRef) => {\n    const { __scopeForm, id: idProp, name, ...messageProps } = props;\n    const ariaDescriptionContext = useAriaDescriptionContext(MESSAGE_NAME, __scopeForm);\n    const _id = useId();\n    const id = idProp ?? _id;\n\n    const { onFieldMessageIdAdd, onFieldMessageIdRemove } = ariaDescriptionContext;\n    React.useEffect(() => {\n      onFieldMessageIdAdd(name, id);\n      return () => onFieldMessageIdRemove(name, id);\n    }, [name, id, onFieldMessageIdAdd, onFieldMessageIdRemove]);\n\n    return <Primitive.span id={id} {...messageProps} ref={forwardedRef} />;\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * FormValidityState\n * -----------------------------------------------------------------------------------------------*/\n\nconst VALIDITY_STATE_NAME = 'FormValidityState';\n\ninterface FormValidityStateProps {\n  children(validity: ValidityState | undefined): React.ReactNode;\n  name?: string;\n}\n\nconst FormValidityState = (props: ScopedProps<FormValidityStateProps>) => {\n  const { __scopeForm, name: nameProp, children } = props;\n  const validationContext = useValidationContext(VALIDITY_STATE_NAME, __scopeForm);\n  const fieldContext = useFormFieldContext(VALIDITY_STATE_NAME, __scopeForm);\n  const name = nameProp ?? fieldContext.name;\n  const validity = validationContext.getFieldValidity(name);\n  return <>{children(validity)}</>;\n};\n\nFormValidityState.displayName = VALIDITY_STATE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * FormSubmit\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUBMIT_NAME = 'FormSubmit';\n\ntype FormSubmitElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface FormSubmitProps extends PrimitiveButtonProps {}\n\nconst FormSubmit = React.forwardRef<FormSubmitElement, FormSubmitProps>(\n  (props: ScopedProps<FormSubmitProps>, forwardedRef) => {\n    const { __scopeForm, ...submitProps } = props;\n    return <Primitive.button type=\"submit\" {...submitProps} ref={forwardedRef} />;\n  }\n);\n\nFormSubmit.displayName = SUBMIT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ValidityStateKey = keyof ValidityState;\ntype SyncCustomMatcher = (value: string, formData: FormData) => boolean;\ntype AsyncCustomMatcher = (value: string, formData: FormData) => Promise<boolean>;\ntype CustomMatcher = SyncCustomMatcher | AsyncCustomMatcher;\ntype CustomMatcherEntry = { id: string; match: CustomMatcher };\ntype SyncCustomMatcherEntry = { id: string; match: SyncCustomMatcher };\ntype AsyncCustomMatcherEntry = { id: string; match: AsyncCustomMatcher };\ntype CustomMatcherArgs = [string, FormData];\n\nfunction validityStateToObject(validity: ValidityState) {\n  const object: any = {};\n  for (const key in validity) {\n    object[key] = validity[key as ValidityStateKey];\n  }\n  return object as Record<ValidityStateKey, boolean>;\n}\n\nfunction isHTMLElement(element: any): element is HTMLElement {\n  return element instanceof HTMLElement;\n}\n\nfunction isFormControl(element: any): element is { validity: ValidityState } {\n  return 'validity' in element;\n}\n\nfunction isInvalid(control: HTMLElement) {\n  return (\n    isFormControl(control) &&\n    (control.validity.valid === false || control.getAttribute('aria-invalid') === 'true')\n  );\n}\n\nfunction getFirstInvalidControl(form: HTMLFormElement): HTMLElement | undefined {\n  const elements = form.elements;\n  const [firstInvalidControl] = Array.from(elements).filter(isHTMLElement).filter(isInvalid);\n  return firstInvalidControl;\n}\n\nfunction isAsyncCustomMatcherEntry(\n  entry: CustomMatcherEntry,\n  args: CustomMatcherArgs\n): entry is AsyncCustomMatcherEntry {\n  return entry.match.constructor.name === 'AsyncFunction' || returnsPromise(entry.match, args);\n}\n\nfunction isSyncCustomMatcherEntry(entry: CustomMatcherEntry): entry is SyncCustomMatcherEntry {\n  return entry.match.constructor.name === 'Function';\n}\n\nfunction returnsPromise(func: Function, args: Array<unknown>) {\n  return func(...args) instanceof Promise;\n}\n\nfunction hasBuiltInError(validity: ValidityState) {\n  let error = false;\n  for (const validityKey in validity) {\n    const key = validityKey as ValidityStateKey;\n    if (key !== 'valid' && key !== 'customError' && validity[key]) {\n      error = true;\n      break;\n    }\n  }\n  return error;\n}\n\nfunction getValidAttribute(validity: ValidityState | undefined, serverInvalid: boolean) {\n  if (validity?.valid === true && !serverInvalid) return true;\n  return undefined;\n}\nfunction getInvalidAttribute(validity: ValidityState | undefined, serverInvalid: boolean) {\n  if (validity?.valid === false || serverInvalid) return true;\n  return undefined;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Form;\nconst Field = FormField;\nconst Label = FormLabel;\nconst Control = FormControl;\nconst Message = FormMessage;\nconst ValidityState = FormValidityState;\nconst Submit = FormSubmit;\n\nexport {\n  createFormScope,\n  //\n  Form,\n  FormField,\n  FormLabel,\n  FormControl,\n  FormMessage,\n  FormValidityState,\n  FormSubmit,\n  //\n  Root,\n  Field,\n  Label,\n  Control,\n  Message,\n  ValidityState,\n  Submit,\n};\n\nexport type {\n  FormProps,\n  FormFieldProps,\n  FormLabelProps,\n  FormControlProps,\n  FormMessageProps,\n  FormValidityStateProps,\n  FormSubmitProps,\n};\n", "import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Label\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Label';\n\ntype LabelElement = React.ComponentRef<typeof Primitive.label>;\ntype PrimitiveLabelProps = React.ComponentPropsWithoutRef<typeof Primitive.label>;\ninterface LabelProps extends PrimitiveLabelProps {}\n\nconst Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {\n  return (\n    <Primitive.label\n      {...props}\n      ref={forwardedRef}\n      onMouseDown={(event) => {\n        // only prevent text selection if clicking inside the label itself\n        const target = event.target as HTMLElement;\n        if (target.closest('button, input, select, textarea')) return;\n\n        props.onMouseDown?.(event);\n        // prevent text selection when double clicking label\n        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();\n      }}\n    />\n  );\n});\n\nLabel.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Label;\n\nexport {\n  Label,\n  //\n  Root,\n};\nexport type { LabelProps };\n", "import * as Primitive from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { unstable_createCollection as createCollection } from '@radix-ui/react-collection';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { useIsHydrated } from '@radix-ui/react-use-is-hydrated';\nimport * as React from 'react';\nimport { flushSync } from 'react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { clamp } from '@radix-ui/number';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\n\ntype InputValidationType = 'alpha' | 'numeric' | 'alphanumeric' | 'none';\n\nconst INPUT_VALIDATION_MAP = {\n  numeric: {\n    type: 'numeric',\n    regexp: /[^\\d]/g,\n    pattern: '\\\\d{1}',\n    inputMode: 'numeric',\n  },\n  alpha: {\n    type: 'alpha',\n    regexp: /[^a-zA-Z]/g,\n    pattern: '[a-zA-Z]{1}',\n    inputMode: 'text',\n  },\n  alphanumeric: {\n    type: 'alphanumeric',\n    regexp: /[^a-zA-Z0-9]/g,\n    pattern: '[a-zA-Z0-9]{1}',\n    inputMode: 'text',\n  },\n  none: null,\n} satisfies InputValidation;\n\n/* -------------------------------------------------------------------------------------------------\n * OneTimePasswordFieldProvider\n * -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupProps = RovingFocusGroup.RovingFocusGroupProps;\n\ninterface OneTimePasswordFieldContextValue {\n  attemptSubmit: () => void;\n  autoComplete: AutoComplete;\n  autoFocus: boolean;\n  disabled: boolean;\n  dispatch: Dispatcher;\n  form: string | undefined;\n  hiddenInputRef: React.RefObject<HTMLInputElement | null>;\n  isHydrated: boolean;\n  name: string | undefined;\n  orientation: Exclude<RovingFocusGroupProps['orientation'], undefined>;\n  placeholder: string | undefined;\n  readOnly: boolean;\n  type: InputType;\n  userActionRef: React.RefObject<KeyboardActionDetails | null>;\n  validationType: InputValidationType;\n  value: string[];\n  sanitizeValue: (arg: string | string[]) => string[];\n}\n\nconst ONE_TIME_PASSWORD_FIELD_NAME = 'OneTimePasswordField';\nconst [Collection, { useCollection, createCollectionScope, useInitCollection }] =\n  createCollection<HTMLInputElement>(ONE_TIME_PASSWORD_FIELD_NAME);\nconst [createOneTimePasswordFieldContext] = createContextScope(ONE_TIME_PASSWORD_FIELD_NAME, [\n  createCollectionScope,\n  createRovingFocusGroupScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\nconst [OneTimePasswordFieldContext, useOneTimePasswordFieldContext] =\n  createOneTimePasswordFieldContext<OneTimePasswordFieldContextValue>(ONE_TIME_PASSWORD_FIELD_NAME);\n\n/* -------------------------------------------------------------------------------------------------\n * OneTimePasswordField\n * -----------------------------------------------------------------------------------------------*/\n\ninterface OneTimePasswordFieldOwnProps {\n  /**\n   * Specifies what\u2014if any\u2014permission the user agent has to provide automated\n   * assistance in filling out form field values, as well as guidance to the\n   * browser as to the type of information expected in the field. Allows\n   * `\"one-time-code\"` or `\"off\"`.\n   *\n   * @defaultValue `\"one-time-code\"`\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/autocomplete\n   */\n  autoComplete?: AutoComplete;\n  /**\n   * Whether or not the first fillable input should be focused on page-load.\n   *\n   * @defaultValue `false`\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/autofocus\n   */\n  autoFocus?: boolean;\n  /**\n   * Whether or not the component should attempt to automatically submit when\n   * all fields are filled. If the field is associated with an HTML `form`\n   * element, the form's `requestSubmit` method will be called.\n   *\n   * @defaultValue `false`\n   */\n  autoSubmit?: boolean;\n  /**\n   * The initial value of the uncontrolled field.\n   */\n  defaultValue?: string;\n  /**\n   * Indicates the horizontal directionality of the parent element's text.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/dir\n   */\n  dir?: RovingFocusGroupProps['dir'];\n  /**\n   * Whether or not the the field's input elements are disabled.\n   */\n  disabled?: boolean;\n  /**\n   * A string specifying the `form` element with which the input is associated.\n   * This string's value, if present, must match the id of a `form` element in\n   * the same document.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#form\n   */\n  form?: string | undefined;\n  /**\n   * A string specifying a name for the input control. This name is submitted\n   * along with the control's value when the form data is submitted.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#name\n   */\n  name?: string | undefined;\n  /**\n   * When the `autoSubmit` prop is set to `true`, this callback will be fired\n   * before attempting to submit the associated form. It will be called whether\n   * or not a form is located, or if submission is not allowed.\n   */\n  onAutoSubmit?: (value: string) => void;\n  /**\n   * A callback fired when the field's value changes. When the component is\n   * controlled, this should update the state passed to the `value` prop.\n   */\n  onValueChange?: (value: string) => void;\n  /**\n   * Indicates the vertical directionality of the input elements.\n   *\n   * @defaultValue `\"horizontal\"`\n   */\n  orientation?: RovingFocusGroupProps['orientation'];\n  /**\n   * Defines the text displayed in a form control when the control has no value.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/placeholder\n   */\n  placeholder?: string | undefined;\n  /**\n   * Whether or not the input elements can be updated by the user.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/readonly\n   */\n  readOnly?: boolean;\n  /**\n   * Function for custom sanitization when `validationType` is set to `\"none\"`.\n   * This function will be called before updating values in response to user\n   * interactions.\n   */\n  sanitizeValue?: (value: string) => string;\n  /**\n   * The input type of the field's input elements. Can be `\"password\"` or `\"text\"`.\n   */\n  type?: InputType;\n  /**\n   * Specifies the type of input validation to be used. Can be `\"alpha\"`,\n   * `\"numeric\"`, `\"alphanumeric\"` or `\"none\"`.\n   *\n   * @defaultValue `\"numeric\"`\n   */\n  validationType?: InputValidationType;\n  /**\n   * The controlled value of the field.\n   */\n  value?: string;\n}\n\ntype ScopedProps<P> = P & { __scopeOneTimePasswordField?: Scope };\n\ninterface OneTimePasswordFieldProps\n  extends OneTimePasswordFieldOwnProps,\n    Omit<Primitive.PrimitivePropsWithRef<'div'>, keyof OneTimePasswordFieldOwnProps> {}\n\nconst OneTimePasswordField = React.forwardRef<HTMLDivElement, OneTimePasswordFieldProps>(\n  function OneTimePasswordFieldImpl(\n    {\n      __scopeOneTimePasswordField,\n      defaultValue,\n      value: valueProp,\n      onValueChange,\n      autoSubmit = false,\n      children,\n      onPaste,\n      onAutoSubmit,\n      disabled = false,\n      readOnly = false,\n      autoComplete = 'one-time-code',\n      autoFocus = false,\n      form,\n      name,\n      placeholder,\n      type = 'text',\n      // TODO: Change default to vertical when inputs use vertical writing mode\n      orientation = 'horizontal',\n      dir,\n      validationType = 'numeric',\n      sanitizeValue: sanitizeValueProp,\n      ...domProps\n    }: ScopedProps<OneTimePasswordFieldProps>,\n    forwardedRef\n  ) {\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeOneTimePasswordField);\n    const direction = useDirection(dir);\n    const collectionState = useInitCollection();\n    const [collection] = collectionState;\n\n    const validation = INPUT_VALIDATION_MAP[validationType]\n      ? INPUT_VALIDATION_MAP[validationType as keyof InputValidation]\n      : null;\n\n    const sanitizeValue = React.useCallback(\n      (value: string | string[]) => {\n        if (Array.isArray(value)) {\n          value = value.map(removeWhitespace).join('');\n        } else {\n          value = removeWhitespace(value);\n        }\n\n        if (validation) {\n          // global regexp is stateful, so we clone it for each call\n          const regexp = new RegExp(validation.regexp);\n          value = value.replace(regexp, '');\n        } else if (sanitizeValueProp) {\n          value = sanitizeValueProp(value);\n        }\n\n        return value.split('');\n      },\n      [validation, sanitizeValueProp]\n    );\n\n    const controlledValue = React.useMemo(() => {\n      return valueProp != null ? sanitizeValue(valueProp) : undefined;\n    }, [valueProp, sanitizeValue]);\n\n    const [value, setValue] = useControllableState({\n      caller: 'OneTimePasswordField',\n      prop: controlledValue,\n      defaultProp: defaultValue != null ? sanitizeValue(defaultValue) : [],\n      onChange: React.useCallback(\n        (value: string[]) => onValueChange?.(value.join('')),\n        [onValueChange]\n      ),\n    });\n\n    // Update function *specifically* for event handlers.\n    const dispatch = useEffectEvent<Dispatcher>((action) => {\n      switch (action.type) {\n        case 'SET_CHAR': {\n          const { index, char } = action;\n          const currentTarget = collection.at(index)?.element;\n          if (value[index] === char) {\n            const next = currentTarget && collection.from(currentTarget, 1)?.element;\n            focusInput(next);\n            return;\n          }\n\n          // empty values should be handled in the CLEAR_CHAR action\n          if (char === '') {\n            return;\n          }\n\n          if (validation) {\n            const regexp = new RegExp(validation.regexp);\n            const clean = char.replace(regexp, '');\n            if (clean !== char) {\n              // not valid; ignore\n              return;\n            }\n          }\n\n          // no more space\n          if (value.length >= collection.size) {\n            // replace current value; move to next input\n            const newValue = [...value];\n            newValue[index] = char;\n            flushSync(() => setValue(newValue));\n            const next = currentTarget && collection.from(currentTarget, 1)?.element;\n            focusInput(next);\n            return;\n          }\n\n          const newValue = [...value];\n          newValue[index] = char;\n\n          const lastElement = collection.at(-1)?.element;\n          flushSync(() => setValue(newValue));\n          if (currentTarget !== lastElement) {\n            const next = currentTarget && collection.from(currentTarget, 1)?.element;\n            focusInput(next);\n          } else {\n            currentTarget?.select();\n          }\n          return;\n        }\n\n        case 'CLEAR_CHAR': {\n          const { index, reason } = action;\n          if (!value[index]) {\n            return;\n          }\n\n          const newValue = value.filter((_, i) => i !== index);\n          const currentTarget = collection.at(index)?.element;\n          const previous = currentTarget && collection.from(currentTarget, -1)?.element;\n\n          flushSync(() => setValue(newValue));\n          if (reason === 'Backspace') {\n            focusInput(previous);\n          } else if (reason === 'Delete' || reason === 'Cut') {\n            focusInput(currentTarget);\n          }\n          return;\n        }\n\n        case 'CLEAR': {\n          if (value.length === 0) {\n            return;\n          }\n\n          if (action.reason === 'Backspace' || action.reason === 'Delete') {\n            flushSync(() => setValue([]));\n            focusInput(collection.at(0)?.element);\n          } else {\n            setValue([]);\n          }\n          return;\n        }\n\n        case 'PASTE': {\n          const { value: pastedValue } = action;\n          const value = sanitizeValue(pastedValue);\n          if (!value) {\n            return;\n          }\n\n          flushSync(() => setValue(value));\n          focusInput(collection.at(value.length - 1)?.element);\n          return;\n        }\n      }\n    });\n\n    // re-validate when the validation type changes\n    const validationTypeRef = React.useRef(validation);\n    React.useEffect(() => {\n      if (!validation) {\n        return;\n      }\n\n      if (validationTypeRef.current?.type !== validation.type) {\n        validationTypeRef.current = validation;\n        setValue(sanitizeValue(value.join('')));\n      }\n    }, [sanitizeValue, setValue, validation, value]);\n\n    const hiddenInputRef = React.useRef<HTMLInputElement>(null);\n\n    const userActionRef = React.useRef<KeyboardActionDetails | null>(null);\n    const rootRef = React.useRef<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, rootRef);\n\n    const firstInput = collection.at(0)?.element;\n    const locateForm = React.useCallback(() => {\n      let formElement: HTMLFormElement | null | undefined;\n      if (form) {\n        const associatedElement = (rootRef.current?.ownerDocument ?? document).getElementById(form);\n        if (isFormElement(associatedElement)) {\n          formElement = associatedElement;\n        }\n      } else if (hiddenInputRef.current) {\n        formElement = hiddenInputRef.current.form;\n      } else if (firstInput) {\n        formElement = firstInput.form;\n      }\n\n      return formElement ?? null;\n    }, [form, firstInput]);\n\n    const attemptSubmit = React.useCallback(() => {\n      const formElement = locateForm();\n      formElement?.requestSubmit();\n    }, [locateForm]);\n\n    React.useEffect(() => {\n      const form = locateForm();\n      if (form) {\n        const reset = () => dispatch({ type: 'CLEAR', reason: 'Reset' });\n        form.addEventListener('reset', reset);\n        return () => form.removeEventListener('reset', reset);\n      }\n    }, [dispatch, locateForm]);\n\n    const currentValue = value.join('');\n    const valueRef = React.useRef(currentValue);\n    const length = collection.size;\n    React.useEffect(() => {\n      const previousValue = valueRef.current;\n      valueRef.current = currentValue;\n      if (previousValue === currentValue) {\n        return;\n      }\n\n      if (autoSubmit && value.every((char) => char !== '') && value.length === length) {\n        onAutoSubmit?.(value.join(''));\n        attemptSubmit();\n      }\n    }, [attemptSubmit, autoSubmit, currentValue, length, onAutoSubmit, value]);\n    const isHydrated = useIsHydrated();\n\n    return (\n      <OneTimePasswordFieldContext\n        scope={__scopeOneTimePasswordField}\n        value={value}\n        attemptSubmit={attemptSubmit}\n        disabled={disabled}\n        readOnly={readOnly}\n        autoComplete={autoComplete}\n        autoFocus={autoFocus}\n        form={form}\n        name={name}\n        placeholder={placeholder}\n        type={type}\n        hiddenInputRef={hiddenInputRef}\n        userActionRef={userActionRef}\n        dispatch={dispatch}\n        validationType={validationType}\n        orientation={orientation}\n        isHydrated={isHydrated}\n        sanitizeValue={sanitizeValue}\n      >\n        <Collection.Provider scope={__scopeOneTimePasswordField} state={collectionState}>\n          <Collection.Slot scope={__scopeOneTimePasswordField}>\n            <RovingFocusGroup.Root\n              asChild\n              {...rovingFocusGroupScope}\n              orientation={orientation}\n              dir={direction}\n            >\n              <Primitive.Root.div\n                {...domProps}\n                role=\"group\"\n                ref={composedRefs}\n                onPaste={composeEventHandlers(\n                  onPaste,\n                  (event: React.ClipboardEvent<HTMLDivElement>) => {\n                    event.preventDefault();\n                    const pastedValue = event.clipboardData.getData('Text');\n                    dispatch({ type: 'PASTE', value: pastedValue });\n                  }\n                )}\n              >\n                {children}\n              </Primitive.Root.div>\n            </RovingFocusGroup.Root>\n          </Collection.Slot>\n        </Collection.Provider>\n      </OneTimePasswordFieldContext>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * OneTimePasswordFieldHiddenInput\n * -----------------------------------------------------------------------------------------------*/\n\ninterface OneTimePasswordFieldHiddenInputProps\n  extends Omit<\n    React.ComponentProps<'input'>,\n    | keyof 'value'\n    | 'defaultValue'\n    | 'type'\n    | 'onChange'\n    | 'readOnly'\n    | 'disabled'\n    | 'autoComplete'\n    | 'autoFocus'\n  > {}\n\nconst OneTimePasswordFieldHiddenInput = React.forwardRef<\n  HTMLInputElement,\n  OneTimePasswordFieldHiddenInputProps\n>(function OneTimePasswordFieldHiddenInput(\n  { __scopeOneTimePasswordField, ...props }: ScopedProps<OneTimePasswordFieldHiddenInputProps>,\n  forwardedRef\n) {\n  const { value, hiddenInputRef, name } = useOneTimePasswordFieldContext(\n    'OneTimePasswordFieldHiddenInput',\n    __scopeOneTimePasswordField\n  );\n  const ref = useComposedRefs(hiddenInputRef, forwardedRef);\n  return (\n    <input\n      ref={ref}\n      name={name}\n      value={value.join('').trim()}\n      autoComplete=\"off\"\n      autoFocus={false}\n      autoCapitalize=\"off\"\n      autoCorrect=\"off\"\n      autoSave=\"off\"\n      spellCheck={false}\n      {...props}\n      type=\"hidden\"\n      readOnly\n    />\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * OneTimePasswordFieldInput\n * -----------------------------------------------------------------------------------------------*/\n\ninterface OneTimePasswordFieldInputProps\n  extends Omit<\n    Primitive.PrimitivePropsWithRef<'input'>,\n    | 'value'\n    | 'defaultValue'\n    | 'disabled'\n    | 'readOnly'\n    | 'autoComplete'\n    | 'autoFocus'\n    | 'form'\n    | 'name'\n    | 'placeholder'\n    | 'type'\n  > {\n  /**\n   * Callback fired when the user input fails native HTML input validation.\n   */\n  onInvalidChange?: (character: string) => void;\n  /**\n   * User-provided index to determine the order of the inputs. This is useful if\n   * you need certain index-based attributes to be set on the initial render,\n   * often to prevent flickering after hydration.\n   */\n  index?: number;\n}\n\nconst OneTimePasswordFieldInput = React.forwardRef<\n  HTMLInputElement,\n  OneTimePasswordFieldInputProps\n>(function OneTimePasswordFieldInput(\n  {\n    __scopeOneTimePasswordField,\n    onInvalidChange,\n    index: indexProp,\n    ...props\n  }: ScopedProps<OneTimePasswordFieldInputProps>,\n  forwardedRef\n) {\n  // TODO: warn if these values are passed\n  const {\n    value: _value,\n    defaultValue: _defaultValue,\n    disabled: _disabled,\n    readOnly: _readOnly,\n    autoComplete: _autoComplete,\n    autoFocus: _autoFocus,\n    form: _form,\n    name: _name,\n    placeholder: _placeholder,\n    type: _type,\n    ...domProps\n  } = props as Primitive.PrimitivePropsWithRef<'input'>;\n\n  const context = useOneTimePasswordFieldContext(\n    'OneTimePasswordFieldInput',\n    __scopeOneTimePasswordField\n  );\n  const { dispatch, userActionRef, validationType, isHydrated, disabled } = context;\n  const collection = useCollection(__scopeOneTimePasswordField);\n  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeOneTimePasswordField);\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [element, setElement] = React.useState<HTMLInputElement | null>(null);\n\n  const index = indexProp ?? (element ? collection.indexOf(element) : -1);\n  const canSetPlaceholder = indexProp != null || isHydrated;\n  let placeholder: string | undefined;\n  if (canSetPlaceholder && context.placeholder && context.value.length === 0) {\n    // only set placeholder after hydration to prevent flickering when indices\n    // are re-calculated\n    placeholder = context.placeholder[index];\n  }\n\n  const composedInputRef = useComposedRefs(forwardedRef, inputRef, setElement);\n  const char = context.value[index] ?? '';\n\n  const keyboardActionTimeoutRef = React.useRef<number | null>(null);\n  React.useEffect(() => {\n    return () => {\n      window.clearTimeout(keyboardActionTimeoutRef.current!);\n    };\n  }, []);\n\n  const totalValue = context.value.join('').trim();\n  const lastSelectableIndex = clamp(totalValue.length, [0, collection.size - 1]);\n  const isFocusable = index <= lastSelectableIndex;\n\n  const validation =\n    validationType in INPUT_VALIDATION_MAP\n      ? INPUT_VALIDATION_MAP[validationType as keyof InputValidation]\n      : undefined;\n\n  return (\n    <Collection.ItemSlot scope={__scopeOneTimePasswordField}>\n      <RovingFocusGroup.Item\n        {...rovingFocusGroupScope}\n        asChild\n        focusable={!context.disabled && isFocusable}\n        active={index === lastSelectableIndex}\n      >\n        {({ hasTabStop, isCurrentTabStop }) => {\n          const supportsAutoComplete = hasTabStop ? isCurrentTabStop : index === 0;\n          return (\n            <Primitive.Root.input\n              ref={composedInputRef}\n              type={context.type}\n              disabled={disabled}\n              aria-label={`Character ${index + 1} of ${collection.size}`}\n              autoComplete={supportsAutoComplete ? context.autoComplete : 'off'}\n              data-1p-ignore={supportsAutoComplete ? undefined : 'true'}\n              data-lpignore={supportsAutoComplete ? undefined : 'true'}\n              data-protonpass-ignore={supportsAutoComplete ? undefined : 'true'}\n              data-bwignore={supportsAutoComplete ? undefined : 'true'}\n              inputMode={validation?.inputMode}\n              maxLength={1}\n              pattern={validation?.pattern}\n              readOnly={context.readOnly}\n              value={char}\n              placeholder={placeholder}\n              data-radix-otp-input=\"\"\n              data-radix-index={index}\n              {...domProps}\n              onFocus={composeEventHandlers(props.onFocus, (event) => {\n                event.currentTarget.select();\n              })}\n              onCut={composeEventHandlers(props.onCut, (event) => {\n                const currentValue = event.currentTarget.value;\n                if (currentValue !== '') {\n                  // In this case the value will be cleared, but we don't want to\n                  // set it directly because the user may want to prevent default\n                  // behavior in the onChange handler. The userActionRef will\n                  // is set temporarily so the change handler can behave correctly\n                  // in response to the action.\n                  userActionRef.current = {\n                    type: 'cut',\n                  };\n                  // Set a short timeout to clear the action tracker after the change\n                  // handler has had time to complete.\n                  keyboardActionTimeoutRef.current = window.setTimeout(() => {\n                    userActionRef.current = null;\n                  }, 10);\n                }\n              })}\n              onInput={composeEventHandlers(props.onInput, (event) => {\n                const value = event.currentTarget.value;\n                if (value.length > 1) {\n                  // Password managers may try to insert the code into a single\n                  // input, in which case form validation will fail to prevent\n                  // additional input. Handle this the same as if a user were\n                  // pasting a value.\n                  event.preventDefault();\n                  dispatch({ type: 'PASTE', value });\n                }\n              })}\n              onChange={composeEventHandlers(props.onChange, (event) => {\n                const value = event.target.value;\n                event.preventDefault();\n                const action = userActionRef.current;\n                userActionRef.current = null;\n\n                if (action) {\n                  switch (action.type) {\n                    case 'cut':\n                      // TODO: do we want to assume the user wantt to clear the\n                      // entire value here and copy the code to the clipboard instead\n                      // of just the value of the given input?\n                      dispatch({ type: 'CLEAR_CHAR', index, reason: 'Cut' });\n                      return;\n                    case 'keydown': {\n                      if (action.key === 'Char') {\n                        // update resulting from a keydown event that set a value\n                        // directly. Ignore.\n                        return;\n                      }\n\n                      const isClearing =\n                        action.key === 'Backspace' && (action.metaKey || action.ctrlKey);\n                      if (action.key === 'Clear' || isClearing) {\n                        dispatch({ type: 'CLEAR', reason: 'Backspace' });\n                      } else {\n                        dispatch({ type: 'CLEAR_CHAR', index, reason: action.key });\n                      }\n                      return;\n                    }\n                    default:\n                      return;\n                  }\n                }\n\n                // Only update the value if it matches the input pattern\n                if (event.target.validity.valid) {\n                  if (value === '') {\n                    let reason: 'Backspace' | 'Delete' | 'Cut' = 'Backspace';\n                    if (isInputEvent(event.nativeEvent)) {\n                      const inputType = event.nativeEvent.inputType;\n                      if (inputType === 'deleteContentBackward') {\n                        reason = 'Backspace';\n                      } else if (inputType === 'deleteByCut') {\n                        reason = 'Cut';\n                      }\n                    }\n                    dispatch({ type: 'CLEAR_CHAR', index, reason });\n                  } else {\n                    dispatch({ type: 'SET_CHAR', char: value, index, event });\n                  }\n                } else {\n                  const element = event.target;\n                  onInvalidChange?.(element.value);\n                  requestAnimationFrame(() => {\n                    if (element.ownerDocument.activeElement === element) {\n                      element.select();\n                    }\n                  });\n                }\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                switch (event.key) {\n                  case 'Clear':\n                  case 'Delete':\n                  case 'Backspace': {\n                    const currentValue = event.currentTarget.value;\n                    // if current value is empty, no change event will fire\n                    if (currentValue === '') {\n                      // if the user presses delete when there is no value, noop\n                      if (event.key === 'Delete') return;\n\n                      const isClearing = event.key === 'Clear' || event.metaKey || event.ctrlKey;\n                      if (isClearing) {\n                        dispatch({ type: 'CLEAR', reason: 'Backspace' });\n                      } else {\n                        const element = event.currentTarget;\n                        requestAnimationFrame(() => {\n                          focusInput(collection.from(element, -1)?.element);\n                        });\n                      }\n                    } else {\n                      // In this case the value will be cleared, but we don't want\n                      // to set it directly because the user may want to prevent\n                      // default behavior in the onChange handler. The userActionRef\n                      // will is set temporarily so the change handler can behave\n                      // correctly in response to the key vs. clearing the value by\n                      // setting state externally.\n                      userActionRef.current = {\n                        type: 'keydown',\n                        key: event.key,\n                        metaKey: event.metaKey,\n                        ctrlKey: event.ctrlKey,\n                      };\n                      // Set a short timeout to clear the action tracker after the change\n                      // handler has had time to complete.\n                      keyboardActionTimeoutRef.current = window.setTimeout(() => {\n                        userActionRef.current = null;\n                      }, 10);\n                    }\n\n                    return;\n                  }\n                  case 'Enter': {\n                    event.preventDefault();\n                    context.attemptSubmit();\n                    return;\n                  }\n                  case 'ArrowDown':\n                  case 'ArrowUp': {\n                    if (context.orientation === 'horizontal') {\n                      // in horizontal orientation, the up/down will de-select the\n                      // input instead of moving focus\n                      event.preventDefault();\n                    }\n                    return;\n                  }\n                  // TODO: Handle left/right arrow keys in vertical writing mode\n                  default: {\n                    if (event.currentTarget.value === event.key) {\n                      // if current value is same as the key press, no change event\n                      // will fire. Focus the next input.\n                      const element = event.currentTarget;\n                      event.preventDefault();\n                      focusInput(collection.from(element, 1)?.element);\n                      return;\n                    } else if (\n                      // input already has a value, but...\n                      event.currentTarget.value &&\n                      // the value is not selected\n                      !(\n                        event.currentTarget.selectionStart === 0 &&\n                        event.currentTarget.selectionEnd != null &&\n                        event.currentTarget.selectionEnd > 0\n                      )\n                    ) {\n                      const attemptedValue = event.key;\n                      if (event.key.length > 1 || event.key === ' ') {\n                        // not a character; do nothing\n                        return;\n                      } else {\n                        // user is attempting to enter a character, but the input\n                        // will not update by default since it's limited to a single\n                        // character.\n                        const nextInput = collection.from(event.currentTarget, 1)?.element;\n                        const lastInput = collection.at(-1)?.element;\n                        if (nextInput !== lastInput && event.currentTarget !== lastInput) {\n                          // if selection is before the value, set the value of the\n                          // current input. Otherwise set the value of the next\n                          // input.\n                          if (event.currentTarget.selectionStart === 0) {\n                            dispatch({ type: 'SET_CHAR', char: attemptedValue, index, event });\n                          } else {\n                            dispatch({\n                              type: 'SET_CHAR',\n                              char: attemptedValue,\n                              index: index + 1,\n                              event,\n                            });\n                          }\n\n                          userActionRef.current = {\n                            type: 'keydown',\n                            key: 'Char',\n                            metaKey: event.metaKey,\n                            ctrlKey: event.ctrlKey,\n                          };\n                          keyboardActionTimeoutRef.current = window.setTimeout(() => {\n                            userActionRef.current = null;\n                          }, 10);\n                        }\n                      }\n                    }\n                  }\n                }\n              })}\n              onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                event.preventDefault();\n                const indexToFocus = Math.min(index, lastSelectableIndex);\n                const element = collection.at(indexToFocus)?.element;\n                focusInput(element);\n              })}\n            />\n          );\n        }}\n      </RovingFocusGroup.Item>\n    </Collection.ItemSlot>\n  );\n});\n\nexport {\n  OneTimePasswordField,\n  OneTimePasswordFieldInput,\n  OneTimePasswordFieldHiddenInput,\n  //\n  OneTimePasswordField as Root,\n  OneTimePasswordFieldInput as Input,\n  OneTimePasswordFieldHiddenInput as HiddenInput,\n};\nexport type {\n  OneTimePasswordFieldProps,\n  OneTimePasswordFieldInputProps,\n  OneTimePasswordFieldHiddenInputProps,\n  InputValidationType,\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isFormElement(element: Element | null | undefined): element is HTMLFormElement {\n  return element?.tagName === 'FORM';\n}\n\nfunction removeWhitespace(value: string) {\n  return value.replace(/\\s/g, '');\n}\n\nfunction focusInput(element: HTMLInputElement | null | undefined) {\n  if (!element) return;\n  if (element.ownerDocument.activeElement === element) {\n    // if the element is already focused, select the value in the next\n    // animation frame\n    window.requestAnimationFrame(() => {\n      element.select?.();\n    });\n  } else {\n    element.focus();\n  }\n}\n\nfunction isInputEvent(event: Event): event is InputEvent {\n  return event.type === 'input';\n}\n\ntype InputType = 'password' | 'text';\ntype AutoComplete = 'off' | 'one-time-code';\ntype KeyboardActionDetails =\n  | {\n      type: 'keydown';\n      key: 'Backspace' | 'Delete' | 'Clear' | 'Char';\n      metaKey: boolean;\n      ctrlKey: boolean;\n    }\n  | { type: 'cut' };\n\ntype UpdateAction =\n  | {\n      type: 'SET_CHAR';\n      char: string;\n      index: number;\n      event: React.KeyboardEvent | React.ChangeEvent;\n    }\n  | { type: 'CLEAR_CHAR'; index: number; reason: 'Backspace' | 'Delete' | 'Cut' }\n  | { type: 'CLEAR'; reason: 'Reset' | 'Backspace' | 'Delete' | 'Clear' }\n  | { type: 'PASTE'; value: string };\ntype Dispatcher = React.Dispatch<UpdateAction>;\ntype InputValidation = Record<\n  InputValidationType,\n  {\n    type: InputValidationType;\n    regexp: RegExp;\n    pattern: string;\n    inputMode: 'text' | 'numeric';\n  } | null\n>;\n", "import * as React from 'react';\nimport { flushSync } from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useId } from '@radix-ui/react-id';\nimport { useIsHydrated } from '@radix-ui/react-use-is-hydrated';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\nimport type { Scope } from '@radix-ui/react-context';\nimport { createContextScope } from '@radix-ui/react-context';\n\nconst PASSWORD_TOGGLE_FIELD_NAME = 'PasswordToggleField';\n\n/* -------------------------------------------------------------------------------------------------\n * PasswordToggleFieldProvider\n * -----------------------------------------------------------------------------------------------*/\n\ntype InternalFocusState = {\n  clickTriggered: boolean;\n  selectionStart: number | null;\n  selectionEnd: number | null;\n};\n\ninterface PasswordToggleFieldContextValue {\n  inputId: string;\n  inputRef: React.RefObject<HTMLInputElement | null>;\n  visible: boolean;\n  setVisible: React.Dispatch<React.SetStateAction<boolean>>;\n  syncInputId: (providedId: string | number | undefined) => void;\n  focusState: React.RefObject<InternalFocusState>;\n}\n\nconst [createPasswordToggleFieldContext] = createContextScope(PASSWORD_TOGGLE_FIELD_NAME);\nconst [PasswordToggleFieldProvider, usePasswordToggleFieldContext] =\n  createPasswordToggleFieldContext<PasswordToggleFieldContextValue>(PASSWORD_TOGGLE_FIELD_NAME);\n\n/* -------------------------------------------------------------------------------------------------\n * PasswordToggleField\n * -----------------------------------------------------------------------------------------------*/\n\ntype ScopedProps<P> = P & { __scopePasswordToggleField?: Scope };\n\ninterface PasswordToggleFieldProps {\n  id?: string;\n  visible?: boolean;\n  defaultVisible?: boolean;\n  onVisiblityChange?: (visible: boolean) => void;\n  children?: React.ReactNode;\n}\n\nconst INITIAL_FOCUS_STATE: InternalFocusState = {\n  clickTriggered: false,\n  selectionStart: null,\n  selectionEnd: null,\n};\n\nconst PasswordToggleField: React.FC<PasswordToggleFieldProps> = ({\n  __scopePasswordToggleField,\n  ...props\n}: ScopedProps<PasswordToggleFieldProps>) => {\n  const baseId = useId(props.id);\n  const defaultInputId = `${baseId}-input`;\n  const [inputIdState, setInputIdState] = React.useState<null | string>(defaultInputId);\n  const inputId = inputIdState ?? defaultInputId;\n  const syncInputId = React.useCallback(\n    (providedId: string | number | undefined) =>\n      setInputIdState(providedId != null ? String(providedId) : null),\n    []\n  );\n\n  const { visible: visibleProp, defaultVisible, onVisiblityChange, children } = props;\n  const [visible = false, setVisible] = useControllableState({\n    caller: PASSWORD_TOGGLE_FIELD_NAME,\n    prop: visibleProp,\n    defaultProp: defaultVisible ?? false,\n    onChange: onVisiblityChange,\n  });\n\n  const inputRef = React.useRef<HTMLInputElement | null>(null);\n  const focusState = React.useRef<InternalFocusState>(INITIAL_FOCUS_STATE);\n\n  return (\n    <PasswordToggleFieldProvider\n      scope={__scopePasswordToggleField}\n      inputId={inputId}\n      inputRef={inputRef}\n      setVisible={setVisible}\n      syncInputId={syncInputId}\n      visible={visible}\n      focusState={focusState}\n    >\n      {children}\n    </PasswordToggleFieldProvider>\n  );\n};\nPasswordToggleField.displayName = PASSWORD_TOGGLE_FIELD_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PasswordToggleFieldInput\n * -----------------------------------------------------------------------------------------------*/\n\nconst PASSWORD_TOGGLE_FIELD_INPUT_NAME = PASSWORD_TOGGLE_FIELD_NAME + 'Input';\n\ntype PrimitiveInputProps = React.ComponentPropsWithoutRef<'input'>;\n\ninterface PasswordToggleFieldOwnProps {\n  autoComplete?: 'current-password' | 'new-password';\n}\n\ninterface PasswordToggleFieldInputProps\n  extends PasswordToggleFieldOwnProps,\n    Omit<PrimitiveInputProps, keyof PasswordToggleFieldOwnProps | 'type'> {\n  autoComplete?: 'current-password' | 'new-password';\n}\n\nconst PasswordToggleFieldInput = React.forwardRef<HTMLInputElement, PasswordToggleFieldInputProps>(\n  (\n    {\n      __scopePasswordToggleField,\n      autoComplete = 'current-password',\n      autoCapitalize = 'off',\n      spellCheck = false,\n      id: idProp,\n      ...props\n    }: ScopedProps<PasswordToggleFieldInputProps>,\n    forwardedRef\n  ) => {\n    const { visible, inputRef, inputId, syncInputId, setVisible, focusState } =\n      usePasswordToggleFieldContext(PASSWORD_TOGGLE_FIELD_INPUT_NAME, __scopePasswordToggleField);\n\n    React.useEffect(() => {\n      syncInputId(idProp);\n    }, [idProp, syncInputId]);\n\n    // We want to reset the visibility to `false` to revert the input to\n    // `type=\"password\"` when:\n    // - The form is reset (for consistency with other form controls)\n    // - The form is submitted (to prevent the browser from remembering the\n    //   input's value.\n    //\n    // See \"Keeping things secure\":\n    //   https://technology.blog.gov.uk/2021/04/19/simple-things-are-complicated-making-a-show-password-option/)\n    const _setVisible = useEffectEvent(setVisible);\n    React.useEffect(() => {\n      const inputElement = inputRef.current;\n      const form = inputElement?.form;\n      if (!form) {\n        return;\n      }\n\n      const controller = new AbortController();\n      form.addEventListener(\n        'reset',\n        (event) => {\n          if (!event.defaultPrevented) {\n            _setVisible(false);\n          }\n        },\n        { signal: controller.signal }\n      );\n      form.addEventListener(\n        'submit',\n        () => {\n          // always reset the visibility on submit regardless of whether the\n          // default action is prevented\n          _setVisible(false);\n        },\n        { signal: controller.signal }\n      );\n      return () => {\n        controller.abort();\n      };\n    }, [inputRef, _setVisible]);\n\n    return (\n      <Primitive.input\n        {...props}\n        id={idProp ?? inputId}\n        autoCapitalize={autoCapitalize}\n        autoComplete={autoComplete}\n        ref={useComposedRefs(forwardedRef, inputRef)}\n        spellCheck={spellCheck}\n        type={visible ? 'text' : 'password'}\n        onBlur={composeEventHandlers(props.onBlur, (event) => {\n          // get the cursor position\n          const { selectionStart, selectionEnd } = event.currentTarget;\n          focusState.current.selectionStart = selectionStart;\n          focusState.current.selectionEnd = selectionEnd;\n        })}\n      />\n    );\n  }\n);\nPasswordToggleFieldInput.displayName = PASSWORD_TOGGLE_FIELD_INPUT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PasswordToggleFieldToggle\n * -----------------------------------------------------------------------------------------------*/\n\nconst PASSWORD_TOGGLE_FIELD_TOGGLE_NAME = PASSWORD_TOGGLE_FIELD_NAME + 'Toggle';\n\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<'button'>;\n\ninterface PasswordToggleFieldToggleProps extends Omit<PrimitiveButtonProps, 'type'> {}\n\nconst PasswordToggleFieldToggle = React.forwardRef<\n  HTMLButtonElement,\n  PasswordToggleFieldToggleProps\n>(\n  (\n    {\n      __scopePasswordToggleField,\n      onClick,\n      onPointerDown,\n      onPointerCancel,\n      onPointerUp,\n      onFocus,\n      children,\n      'aria-label': ariaLabelProp,\n      'aria-controls': ariaControls,\n      'aria-hidden': ariaHidden,\n      tabIndex,\n      ...props\n    }: ScopedProps<PasswordToggleFieldToggleProps>,\n    forwardedRef\n  ) => {\n    const { setVisible, visible, inputRef, inputId, focusState } = usePasswordToggleFieldContext(\n      PASSWORD_TOGGLE_FIELD_TOGGLE_NAME,\n      __scopePasswordToggleField\n    );\n    const [internalAriaLabel, setInternalAriaLabel] = React.useState<string | undefined>(undefined);\n    const elementRef = React.useRef<HTMLButtonElement>(null);\n    const ref = useComposedRefs(forwardedRef, elementRef);\n    const isHydrated = useIsHydrated();\n\n    React.useEffect(() => {\n      const element = elementRef.current;\n      if (!element || ariaLabelProp) {\n        setInternalAriaLabel(undefined);\n        return;\n      }\n\n      const DEFAULT_ARIA_LABEL = visible ? 'Hide password' : 'Show password';\n\n      function checkForInnerTextLabel(textContent: string | undefined | null) {\n        const text = textContent ? textContent : undefined;\n        // If the element has inner text, no need to force an aria-label.\n        setInternalAriaLabel(text ? undefined : DEFAULT_ARIA_LABEL);\n      }\n\n      checkForInnerTextLabel(element.textContent);\n\n      const observer = new MutationObserver((entries) => {\n        let textContent: string | undefined;\n        for (const entry of entries) {\n          if (entry.type === 'characterData') {\n            if (element.textContent) {\n              textContent = element.textContent;\n            }\n          }\n        }\n        checkForInnerTextLabel(textContent);\n      });\n      observer.observe(element, { characterData: true, subtree: true });\n      return () => {\n        observer.disconnect();\n      };\n    }, [visible, ariaLabelProp]);\n\n    const ariaLabel = ariaLabelProp || internalAriaLabel;\n\n    // Before hydration the button will not work, but we want to render it\n    // regardless to prevent potential layout shift. Hide it from assistive tech\n    // by default. Post-hydration it will be visible, focusable and associated\n    // with the input via aria-controls.\n    if (!isHydrated) {\n      ariaHidden ??= true;\n      tabIndex ??= -1;\n    } else {\n      ariaControls ??= inputId;\n    }\n\n    React.useEffect(() => {\n      let cleanup = () => {};\n      const ownerWindow = elementRef.current?.ownerDocument?.defaultView || window;\n      const reset = () => (focusState.current.clickTriggered = false);\n      const handlePointerUp = () => (cleanup = requestIdleCallback(ownerWindow, reset));\n      ownerWindow.addEventListener('pointerup', handlePointerUp);\n      return () => {\n        cleanup();\n        ownerWindow.removeEventListener('pointerup', handlePointerUp);\n      };\n    }, [focusState]);\n\n    return (\n      <Primitive.button\n        aria-controls={ariaControls}\n        aria-hidden={ariaHidden}\n        aria-label={ariaLabel}\n        ref={ref}\n        id={inputId}\n        {...props}\n        onPointerDown={composeEventHandlers(onPointerDown, () => {\n          focusState.current.clickTriggered = true;\n        })}\n        onPointerCancel={(event) => {\n          // do not use `composeEventHandlers` here because we always want to\n          // reset the ref on cancellation, regardless of whether the user has\n          // called preventDefault on the event\n          onPointerCancel?.(event);\n          focusState.current = INITIAL_FOCUS_STATE;\n        }}\n        // do not use `composeEventHandlers` here because we always want to\n        // reset the ref after click, regardless of whether the user has\n        // called preventDefault on the event\n        onClick={(event) => {\n          onClick?.(event);\n          if (event.defaultPrevented) {\n            focusState.current = INITIAL_FOCUS_STATE;\n            return;\n          }\n\n          flushSync(() => {\n            setVisible((s) => !s);\n          });\n          if (focusState.current.clickTriggered) {\n            const input = inputRef.current;\n            if (input) {\n              const { selectionStart, selectionEnd } = focusState.current;\n              input.focus();\n              if (selectionStart !== null || selectionEnd !== null) {\n                // wait a tick so that focus has settled, then restore select position\n                requestAnimationFrame(() => {\n                  // make sure the input still has focus (developer may have\n                  // programatically moved focus elsewhere)\n                  if (input.ownerDocument.activeElement === input) {\n                    input.selectionStart = selectionStart;\n                    input.selectionEnd = selectionEnd;\n                  }\n                });\n              }\n            }\n          }\n          focusState.current = INITIAL_FOCUS_STATE;\n        }}\n        onPointerUp={(event) => {\n          onPointerUp?.(event);\n          // if click handler hasn't been called at this point, it may have been\n          // intercepted, in which case we still want to reset our internal\n          // state\n          setTimeout(() => {\n            focusState.current = INITIAL_FOCUS_STATE;\n          }, 50);\n        }}\n        type=\"button\"\n      >\n        {children}\n      </Primitive.button>\n    );\n  }\n);\nPasswordToggleFieldToggle.displayName = PASSWORD_TOGGLE_FIELD_TOGGLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PasswordToggleFieldSlot\n * -----------------------------------------------------------------------------------------------*/\n\nconst PASSWORD_TOGGLE_FIELD_SLOT_NAME = PASSWORD_TOGGLE_FIELD_NAME + 'Slot';\n\ninterface PasswordToggleFieldSlotDeclarativeProps {\n  visible: React.ReactNode;\n  hidden: React.ReactNode;\n}\n\ninterface PasswordToggleFieldSlotRenderProps {\n  render: (args: { visible: boolean }) => React.ReactElement;\n}\n\ntype PasswordToggleFieldSlotProps =\n  | PasswordToggleFieldSlotDeclarativeProps\n  | PasswordToggleFieldSlotRenderProps;\n\nconst PasswordToggleFieldSlot: React.FC<PasswordToggleFieldSlotProps> = ({\n  __scopePasswordToggleField,\n  ...props\n}: ScopedProps<PasswordToggleFieldSlotProps>) => {\n  const { visible } = usePasswordToggleFieldContext(\n    PASSWORD_TOGGLE_FIELD_SLOT_NAME,\n    __scopePasswordToggleField\n  );\n\n  return 'render' in props\n    ? //\n      props.render({ visible })\n    : visible\n      ? props.visible\n      : props.hidden;\n};\nPasswordToggleFieldSlot.displayName = PASSWORD_TOGGLE_FIELD_SLOT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PasswordToggleFieldIcon\n * -----------------------------------------------------------------------------------------------*/\n\nconst PASSWORD_TOGGLE_FIELD_ICON_NAME = PASSWORD_TOGGLE_FIELD_NAME + 'Icon';\n\ntype PrimitiveSvgProps = React.ComponentPropsWithoutRef<'svg'>;\n\ninterface PasswordToggleFieldIconProps extends Omit<PrimitiveSvgProps, 'children'> {\n  visible: React.ReactElement;\n  hidden: React.ReactElement;\n}\n\nconst PasswordToggleFieldIcon = React.forwardRef<SVGSVGElement, PasswordToggleFieldIconProps>(\n  (\n    {\n      __scopePasswordToggleField,\n      // @ts-expect-error\n      children,\n      ...props\n    }: ScopedProps<PasswordToggleFieldIconProps>,\n    forwardedRef\n  ) => {\n    const { visible } = usePasswordToggleFieldContext(\n      PASSWORD_TOGGLE_FIELD_ICON_NAME,\n      __scopePasswordToggleField\n    );\n    const { visible: visibleIcon, hidden: hiddenIcon, ...domProps } = props;\n    return (\n      <Primitive.svg {...domProps} ref={forwardedRef} aria-hidden asChild>\n        {visible ? visibleIcon : hiddenIcon}\n      </Primitive.svg>\n    );\n  }\n);\nPasswordToggleFieldIcon.displayName = PASSWORD_TOGGLE_FIELD_ICON_NAME;\n\nexport {\n  PasswordToggleField,\n  PasswordToggleFieldInput,\n  PasswordToggleFieldToggle,\n  PasswordToggleFieldSlot,\n  PasswordToggleFieldIcon,\n  //\n  PasswordToggleField as Root,\n  PasswordToggleFieldInput as Input,\n  PasswordToggleFieldToggle as Toggle,\n  PasswordToggleFieldSlot as Slot,\n  PasswordToggleFieldIcon as Icon,\n};\nexport type {\n  PasswordToggleFieldProps,\n  PasswordToggleFieldInputProps,\n  PasswordToggleFieldToggleProps,\n  PasswordToggleFieldIconProps,\n  PasswordToggleFieldSlotProps,\n};\n\nfunction requestIdleCallback(\n  window: Window,\n  callback: IdleRequestCallback,\n  options?: IdleRequestOptions\n): () => void {\n  if ((window as any).requestIdleCallback) {\n    const id = window.requestIdleCallback(callback, options);\n    return () => {\n      window.cancelIdleCallback(id);\n    };\n  }\n  const start = Date.now();\n  const id = window.setTimeout(() => {\n    const timeRemaining = () => Math.max(0, 50 - (Date.now() - start));\n    callback({ didTimeout: false, timeRemaining });\n  }, 1);\n  return () => {\n    window.clearTimeout(id);\n  };\n}\n", "import * as React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Progress\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROGRESS_NAME = 'Progress';\nconst DEFAULT_MAX = 100;\n\ntype ScopedProps<P> = P & { __scopeProgress?: Scope };\nconst [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);\n\ntype ProgressState = 'indeterminate' | 'complete' | 'loading';\ntype ProgressContextValue = { value: number | null; max: number };\nconst [ProgressProvider, useProgressContext] =\n  createProgressContext<ProgressContextValue>(PROGRESS_NAME);\n\ntype ProgressElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ProgressProps extends PrimitiveDivProps {\n  value?: number | null | undefined;\n  max?: number;\n  getValueLabel?(value: number, max: number): string;\n}\n\nconst Progress = React.forwardRef<ProgressElement, ProgressProps>(\n  (props: ScopedProps<ProgressProps>, forwardedRef) => {\n    const {\n      __scopeProgress,\n      value: valueProp = null,\n      max: maxProp,\n      getValueLabel = defaultGetValueLabel,\n      ...progressProps\n    } = props;\n\n    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {\n      console.error(getInvalidMaxError(`${maxProp}`, 'Progress'));\n    }\n\n    const max = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;\n\n    if (valueProp !== null && !isValidValueNumber(valueProp, max)) {\n      console.error(getInvalidValueError(`${valueProp}`, 'Progress'));\n    }\n\n    const value = isValidValueNumber(valueProp, max) ? valueProp : null;\n    const valueLabel = isNumber(value) ? getValueLabel(value, max) : undefined;\n\n    return (\n      <ProgressProvider scope={__scopeProgress} value={value} max={max}>\n        <Primitive.div\n          aria-valuemax={max}\n          aria-valuemin={0}\n          aria-valuenow={isNumber(value) ? value : undefined}\n          aria-valuetext={valueLabel}\n          role=\"progressbar\"\n          data-state={getProgressState(value, max)}\n          data-value={value ?? undefined}\n          data-max={max}\n          {...progressProps}\n          ref={forwardedRef}\n        />\n      </ProgressProvider>\n    );\n  }\n);\n\nProgress.displayName = PROGRESS_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ProgressIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'ProgressIndicator';\n\ntype ProgressIndicatorElement = React.ComponentRef<typeof Primitive.div>;\ninterface ProgressIndicatorProps extends PrimitiveDivProps {}\n\nconst ProgressIndicator = React.forwardRef<ProgressIndicatorElement, ProgressIndicatorProps>(\n  (props: ScopedProps<ProgressIndicatorProps>, forwardedRef) => {\n    const { __scopeProgress, ...indicatorProps } = props;\n    const context = useProgressContext(INDICATOR_NAME, __scopeProgress);\n    return (\n      <Primitive.div\n        data-state={getProgressState(context.value, context.max)}\n        data-value={context.value ?? undefined}\n        data-max={context.max}\n        {...indicatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nProgressIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction defaultGetValueLabel(value: number, max: number) {\n  return `${Math.round((value / max) * 100)}%`;\n}\n\nfunction getProgressState(value: number | undefined | null, maxValue: number): ProgressState {\n  return value == null ? 'indeterminate' : value === maxValue ? 'complete' : 'loading';\n}\n\nfunction isNumber(value: any): value is number {\n  return typeof value === 'number';\n}\n\nfunction isValidMaxNumber(max: any): max is number {\n  // prettier-ignore\n  return (\n    isNumber(max) &&\n    !isNaN(max) &&\n    max > 0\n  );\n}\n\nfunction isValidValueNumber(value: any, max: number): value is number {\n  // prettier-ignore\n  return (\n    isNumber(value) &&\n    !isNaN(value) &&\n    value <= max &&\n    value >= 0\n  );\n}\n\n// Split this out for clearer readability of the error message.\nfunction getInvalidMaxError(propValue: string, componentName: string) {\n  return `Invalid prop \\`max\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${DEFAULT_MAX}\\`.`;\n}\n\nfunction getInvalidValueError(propValue: string, componentName: string) {\n  return `Invalid prop \\`value\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${DEFAULT_MAX} if no \\`max\\` prop is set)\n  - \\`null\\` or \\`undefined\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`;\n}\n\nconst Root = Progress;\nconst Indicator = ProgressIndicator;\n\nexport {\n  createProgressScope,\n  //\n  Progress,\n  ProgressIndicator,\n  //\n  Root,\n  Indicator,\n};\nexport type { ProgressProps, ProgressIndicatorProps };\n", "import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n *  Separator\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Separator';\nconst DEFAULT_ORIENTATION = 'horizontal';\nconst ORIENTATIONS = ['horizontal', 'vertical'] as const;\n\ntype Orientation = (typeof ORIENTATIONS)[number];\ntype SeparatorElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface SeparatorProps extends PrimitiveDivProps {\n  /**\n   * Either `vertical` or `horizontal`. Defaults to `horizontal`.\n   */\n  orientation?: Orientation;\n  /**\n   * Whether or not the component is purely decorative. When true, accessibility-related attributes\n   * are updated so that that the rendered element is removed from the accessibility tree.\n   */\n  decorative?: boolean;\n}\n\nconst Separator = React.forwardRef<SeparatorElement, SeparatorProps>((props, forwardedRef) => {\n  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;\n  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;\n  // `aria-orientation` defaults to `horizontal` so we only need it if `orientation` is vertical\n  const ariaOrientation = orientation === 'vertical' ? orientation : undefined;\n  const semanticProps = decorative\n    ? { role: 'none' }\n    : { 'aria-orientation': ariaOrientation, role: 'separator' };\n\n  return (\n    <Primitive.div\n      data-orientation={orientation}\n      {...semanticProps}\n      {...domProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nSeparator.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isValidOrientation(orientation: any): orientation is Orientation {\n  return ORIENTATIONS.includes(orientation);\n}\n\nconst Root = Separator;\n\nexport {\n  Separator,\n  //\n  Root,\n};\nexport type { SeparatorProps };\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ComponentRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `\u2020` and `t !== \u2020`\n        const isHotkeyPressed =\n          hotkey.length !== 0 && hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ComponentRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen ?? true,\n      onChange: onOpenChange,\n      caller: TOAST_NAME,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ComponentRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as SeparatorPrimitive from '@radix-ui/react-separator';\nimport * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';\nimport { createToggleGroupScope } from '@radix-ui/react-toggle-group';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Toolbar\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLBAR_NAME = 'Toolbar';\n\ntype ScopedProps<P> = P & { __scopeToolbar?: Scope };\nconst [createToolbarContext, createToolbarScope] = createContextScope(TOOLBAR_NAME, [\n  createRovingFocusGroupScope,\n  createToggleGroupScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\nconst useToggleGroupScope = createToggleGroupScope();\n\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype ToolbarContextValue = {\n  orientation: RovingFocusGroupProps['orientation'];\n  dir: RovingFocusGroupProps['dir'];\n};\nconst [ToolbarProvider, useToolbarContext] =\n  createToolbarContext<ToolbarContextValue>(TOOLBAR_NAME);\n\ntype ToolbarElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToolbarProps extends PrimitiveDivProps {\n  orientation?: RovingFocusGroupProps['orientation'];\n  loop?: RovingFocusGroupProps['loop'];\n  dir?: RovingFocusGroupProps['dir'];\n}\n\nconst Toolbar = React.forwardRef<ToolbarElement, ToolbarProps>(\n  (props: ScopedProps<ToolbarProps>, forwardedRef) => {\n    const { __scopeToolbar, orientation = 'horizontal', dir, loop = true, ...toolbarProps } = props;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);\n    const direction = useDirection(dir);\n    return (\n      <ToolbarProvider scope={__scopeToolbar} orientation={orientation} dir={direction}>\n        <RovingFocusGroup.Root\n          asChild\n          {...rovingFocusGroupScope}\n          orientation={orientation}\n          dir={direction}\n          loop={loop}\n        >\n          <Primitive.div\n            role=\"toolbar\"\n            aria-orientation={orientation}\n            dir={direction}\n            {...toolbarProps}\n            ref={forwardedRef}\n          />\n        </RovingFocusGroup.Root>\n      </ToolbarProvider>\n    );\n  }\n);\n\nToolbar.displayName = TOOLBAR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToolbarSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'ToolbarSeparator';\n\ntype ToolbarSeparatorElement = React.ComponentRef<typeof SeparatorPrimitive.Root>;\ntype SeparatorProps = React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>;\ninterface ToolbarSeparatorProps extends SeparatorProps {}\n\nconst ToolbarSeparator = React.forwardRef<ToolbarSeparatorElement, ToolbarSeparatorProps>(\n  (props: ScopedProps<ToolbarSeparatorProps>, forwardedRef) => {\n    const { __scopeToolbar, ...separatorProps } = props;\n    const context = useToolbarContext(SEPARATOR_NAME, __scopeToolbar);\n    return (\n      <SeparatorPrimitive.Root\n        orientation={context.orientation === 'horizontal' ? 'vertical' : 'horizontal'}\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nToolbarSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToolbarButton\n * -----------------------------------------------------------------------------------------------*/\n\nconst BUTTON_NAME = 'ToolbarButton';\n\ntype ToolbarButtonElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToolbarButtonProps extends PrimitiveButtonProps {}\n\nconst ToolbarButton = React.forwardRef<ToolbarButtonElement, ToolbarButtonProps>(\n  (props: ScopedProps<ToolbarButtonProps>, forwardedRef) => {\n    const { __scopeToolbar, ...buttonProps } = props;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);\n    return (\n      <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!props.disabled}>\n        <Primitive.button type=\"button\" {...buttonProps} ref={forwardedRef} />\n      </RovingFocusGroup.Item>\n    );\n  }\n);\n\nToolbarButton.displayName = BUTTON_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToolbarLink\n * -----------------------------------------------------------------------------------------------*/\n\nconst LINK_NAME = 'ToolbarLink';\n\ntype ToolbarLinkElement = React.ComponentRef<typeof Primitive.a>;\ntype PrimitiveLinkProps = React.ComponentPropsWithoutRef<typeof Primitive.a>;\ninterface ToolbarLinkProps extends PrimitiveLinkProps {}\n\nconst ToolbarLink = React.forwardRef<ToolbarLinkElement, ToolbarLinkProps>(\n  (props: ScopedProps<ToolbarLinkProps>, forwardedRef) => {\n    const { __scopeToolbar, ...linkProps } = props;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);\n    return (\n      <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable>\n        <Primitive.a\n          {...linkProps}\n          ref={forwardedRef}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === ' ') event.currentTarget.click();\n          })}\n        />\n      </RovingFocusGroup.Item>\n    );\n  }\n);\n\nToolbarLink.displayName = LINK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToolbarToggleGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOGGLE_GROUP_NAME = 'ToolbarToggleGroup';\n\ntype ToolbarToggleGroupElement = React.ComponentRef<typeof ToggleGroupPrimitive.Root>;\ntype ToggleGroupProps = React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root>;\ninterface ToolbarToggleGroupSingleProps extends Extract<ToggleGroupProps, { type: 'single' }> {}\ninterface ToolbarToggleGroupMultipleProps extends Extract<ToggleGroupProps, { type: 'multiple' }> {}\n\nconst ToolbarToggleGroup = React.forwardRef<\n  ToolbarToggleGroupElement,\n  ToolbarToggleGroupSingleProps | ToolbarToggleGroupMultipleProps\n>(\n  (\n    props: ScopedProps<ToolbarToggleGroupSingleProps | ToolbarToggleGroupMultipleProps>,\n    forwardedRef\n  ) => {\n    const { __scopeToolbar, ...toggleGroupProps } = props;\n    const context = useToolbarContext(TOGGLE_GROUP_NAME, __scopeToolbar);\n    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);\n    return (\n      <ToggleGroupPrimitive.Root\n        data-orientation={context.orientation}\n        dir={context.dir}\n        {...toggleGroupScope}\n        {...toggleGroupProps}\n        ref={forwardedRef}\n        rovingFocus={false}\n      />\n    );\n  }\n);\n\nToolbarToggleGroup.displayName = TOGGLE_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToolbarToggleItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOGGLE_ITEM_NAME = 'ToolbarToggleItem';\n\ntype ToolbarToggleItemElement = React.ComponentRef<typeof ToggleGroupPrimitive.Item>;\ntype ToggleGroupItemProps = React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item>;\ninterface ToolbarToggleItemProps extends ToggleGroupItemProps {}\n\nconst ToolbarToggleItem = React.forwardRef<ToolbarToggleItemElement, ToolbarToggleItemProps>(\n  (props: ScopedProps<ToolbarToggleItemProps>, forwardedRef) => {\n    const { __scopeToolbar, ...toggleItemProps } = props;\n    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);\n    const scope = { __scopeToolbar: props.__scopeToolbar };\n\n    return (\n      <ToolbarButton asChild {...scope}>\n        <ToggleGroupPrimitive.Item {...toggleGroupScope} {...toggleItemProps} ref={forwardedRef} />\n      </ToolbarButton>\n    );\n  }\n);\n\nToolbarToggleItem.displayName = TOGGLE_ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst Root = Toolbar;\nconst Separator = ToolbarSeparator;\nconst Button = ToolbarButton;\nconst Link = ToolbarLink;\nconst ToggleGroup = ToolbarToggleGroup;\nconst ToggleItem = ToolbarToggleItem;\n\nexport {\n  createToolbarScope,\n  //\n  Toolbar,\n  ToolbarSeparator,\n  ToolbarButton,\n  ToolbarLink,\n  ToolbarToggleGroup,\n  ToolbarToggleItem,\n  //\n  Root,\n  Separator,\n  Button,\n  Link,\n  ToggleGroup,\n  ToggleItem,\n};\nexport type {\n  ToolbarProps,\n  ToolbarSeparatorProps,\n  ToolbarButtonProps,\n  ToolbarLinkProps,\n  ToolbarToggleGroupSingleProps,\n  ToolbarToggleGroupMultipleProps,\n  ToolbarToggleItemProps,\n};\n"],
  "mappings": "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",
  "names": ["Root", "React", "import_jsx_runtime", "NAME", "React", "import_jsx_runtime", "React", "React", "import_jsx_runtime", "NAME", "import_jsx_runtime", "controlValidity", "id", "hasCustomError", "React", "import_jsx_runtime", "value", "newValue", "form", "Root", "OneTimePasswordFieldHiddenInput", "OneTimePasswordFieldInput", "element", "React", "import_react_dom", "import_jsx_runtime", "window", "id", "React", "import_jsx_runtime", "React", "import_jsx_runtime", "NAME", "Root", "React", "import_jsx_runtime", "Collection", "useCollection", "createCollectionScope", "node", "duration", "Root", "clamp", "event", "isHTMLElement", "React", "import_jsx_runtime", "useRovingFocusGroupScope", "Root", "Root2"]
}
