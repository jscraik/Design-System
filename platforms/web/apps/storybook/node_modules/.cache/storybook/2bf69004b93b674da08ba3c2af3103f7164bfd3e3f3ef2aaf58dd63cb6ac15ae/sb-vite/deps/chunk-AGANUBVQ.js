import {
  require_jsx_runtime
} from "./chunk-SOYICBYQ.js";
import {
  require_react
} from "./chunk-SVZU6VD4.js";
import {
  __toESM
} from "./chunk-PLDDJCW6.js";

// ../../../../node_modules/.pnpm/@openai+apps-sdk-ui@0.2.1_@types+react-dom@19.2.3_@types+react@19.2.7__@types+react@19._66a90e86b922f9fa759e20bb3fdb6c95/node_modules/@openai/apps-sdk-ui/dist/es/lib/renderHelpers.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var flattenTextNodes = (children) => {
  const nodes = import_react.Children.toArray(children);
  const result = [];
  let buffer = "";
  const flush = () => {
    if (buffer !== "") {
      result.push(buffer);
      buffer = "";
    }
  };
  for (const node of nodes) {
    if (node == null || typeof node === "boolean") {
      continue;
    }
    if (typeof node === "string" || typeof node === "number") {
      buffer += String(node);
      continue;
    }
    flush();
    result.push(node);
  }
  flush();
  return result;
};
var wrapTextNodeSiblings = (children) => {
  const flattenedChildren = flattenTextNodes(children);
  const childrenCount = import_react.Children.count(flattenedChildren);
  return import_react.Children.map(flattenedChildren, (child) => {
    if (typeof child === "string" && !!child.trim()) {
      if (childrenCount <= 1) {
        return child;
      }
      return (0, import_jsx_runtime.jsx)("span", { children: child });
    }
    if ((0, import_react.isValidElement)(child)) {
      const element = child;
      const { children: innerChildren, ...restProps } = element.props;
      if (innerChildren != null) {
        return (0, import_react.cloneElement)(element, restProps, wrapTextNodeSiblings(innerChildren));
      }
      return element;
    }
    return child;
  });
};

export {
  wrapTextNodeSiblings
};
//# sourceMappingURL=chunk-AGANUBVQ.js.map
