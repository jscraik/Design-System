Today we're going to look at how to vibe code your Figma variables in a way that will work for light mode and dark mode and also for desktop and mobile as well. We're going to do this using cursor where we generate a JSON file after giving the AI specific rules around the different collections that we're going to want and then uploading this JSON file to T token studio. And no, you do not need any technical background. Let's dive in. If you're a big fan of myself and what we're doing at UI Collective, consider checking out our academy. I'll put a link for this down below where you get access to our range of courses on things like design systems, vibe coding, AI and design, and really everything in between. Thanks for your support. All right, let's look at building our design tokens with AI. I was actually going to make this a course for our academy, but then I realized to start the year that I should be a man of the people and put this for free on YouTube. So, here it is for everyone to enjoy. Let's rock and roll. All right, a little disclaimer is that you should have a fundamental knowledge of design tokens to watch this video, but it's not mandatory. If you're coming in here and you have no idea what a design token is, you I know have no idea how Figma variable should be structured, you might struggle. I'm going to put some links down below where I go through the process of actually building out Figma variable libraries and really walking everyone through design tokens at a much much slower pace. So, if this is you and you're watching this, you have no idea what a design token is, I'm going to put a couple links down below for you to take a look at. But again, having a fundamental knowledge of design tokens is not mandatory to watch, but it will help. Now, also for this video is we're going to be using a three- tiered approach to design token architecture, leveraging a brand collection, an alias collection, and a mapped collection. If you have no idea what those are, I would watch the links that I do put down below. But if you do, you can also use this process for a two-tiered approach. So, just using a primitive and semantic. The beauty about what we're covering today is you can really make it your own. We're going to cover rules at a high level. And those rules can be really customized around what you want for your design system and the different types of um tiered approaches, whether three- tiered approach or two-tiered approach that you want to implement when you're building your design tokens. So, just as another disclaimer, we're going to be using a three- tiered approach, but you absolutely absolutely do not need to use the same approach that we are. You can use a two-tier being a primitive and semantic approach to your design tokens. Now, here's a highle table of contents of what we're going to look at in the video because I might be bouncing back and forth quite a bit. Now, one thing I did include here is we are going to still connect uh a cursor via fig to Figma via MCP so that we can import just our raw scales. Um I know I sorry I should have included that in here. But then from that we're going to include look at building rules to inform the AI which is relatively self-explanatory. Then we're building a command on generating the actual tokens itself. So not something that's like oh just build me design tokens but actually orchestrating all the rules that we want to build within one solid workflow. And then we're going to use token studio to import those uh the tokens that we generate to Figma and talk about some logistics of importing variables. As I said, I might be bouncing back and forth quite a bit to cover different concepts. Uh but here's the highle table of contents to what to expect for this. We are going to be using cursor. If you're not too sure what cursor is, it's just a vibe coding tool. So go ahead, go to cursor.com, download cursor, create an account. Uh and now let's go ahead and connect Figma MCP. So, if you go to Figma MCP catalog, I'll also put a link for this in the description, too. Just scroll down uh where you see cursor and just hit add MCP to cursor. It's going to open up a little uh modal that I know you can't see on my screen recording right now, and it's going to tell you to open cursor. So, just hit open cursor. Then, when you navigate back to cursor, you're going to see this. So, here we're just in inside of tools and MCP within our cursor settings uh with this pre-populated. So, just hit install. Uh and now you're going to see that Figma needs authentication. So go ahead, hit connect, and that's going to open up Figma in the browser. You're going to see this. Just go ahead, hit agree and allow access. It's going to ask you to open up cursor again. So go ahead and do that. When we navigate back to cursor, you can see here that the Figma MCP server is now properly installed. Now, what this is going to allow us to do is actually take items inside of Figma, upload it to Cursor, and Cursor can actually or the AI via Figma MCP can actually read the Figma file. Now, if you already have color scales, this is the reason why we connected Figma MCP is because you can upload just pure color scales on a Figma frame and have AI actually study it using the rules that we're going to build, therefore build out your design token architecture that we can upload to Figma. So, that is the reason why we have connected our Figma MCP, but more to come on that a little bit later. Now, here comes the fun part. We're actually going to be building rules that's going to inform the AI to help generate our design tokens. Now, you should know by now that your design token should not live within one collection. If you have every single type of Figma variable in just one Figma collection that you just call colors or design system tokens, you're doing something wrong. You should know that your design tokens, like there's different ways to approach them. usually a two-tiered approach with a primitive and semantic and a three- tiered approach with a brand alias in that. So, when we're actually going through and building the rules, we're going to be building the rules around the different collections that we're going to want. Brand collection, alias collection, mapped collection, responsive collection. If you're a two-tiered approach, this is primitive collection, and semantic collection. Now, if you're new here, this is where things might get a little bit confusing, but I'm going to try to go as slow as possible so that you'll be able to understand it as well. Also, too, another thing that I would like to call out is we are going to be building the rules kind of almost referencing a completed design system. Now, you don't need a completed design system in order to do this. I'm just going to be referencing it because it might help you follow along so you can see sort of the context to where I'm coming from when I'm building the rules. But the rules that I'm going to build are going to be super high level. The more you inform the rules on your own, the better the result is going to be. Now, if you are here for the first time, I'm going to spend just two or three minutes just covering the brand alias and mapped collections at a super high level, but if you're new here, you can probably skip the next two minutes. So, what are the three collections that we're rocking with today? Now, I'm going to cover this with a tree example, which I've used in other types of videos before, but the three collections, now I say three, but we're also going to be building a responsive collection, too, which handles like responsive type and things like that. More on that later, but it's not included in this tree diagram where this is really just only focused on colors where we're only working with three collections. We're going to look at the completed each completed versions of each of these very shortly. But starting off with our brand collection, what your brand collection is is sort of all your raw scales in their purest forms. Your purples, your reds, your greens. They don't have any meaning yet. where we start to apply meaning and sorry if I think back to the tree example is your brand collection are the roots of the tree without strong a strong foundation or a strong brand collection tree is going to fall down and your design token is going to be a disaster so what this does is it just really helps us uh if I go into a completed brand collection here sorry I wish I had a bigger monitor so I could fit more in you can see here it's just all of our colors just in the raw scales they have no meaning yet that is the brand collection where we start to apply meaning meeting meaning not meeting um is the alias collection where we sort of assign red's the role of errors green's the role of success purple's in the case of UI collective a primary color so we're this is where we really start to apply different semantic meanings and if I go into our alias collection you'll see what I mean so in the case of this just completed design system we have our primary which is the slate connects back to the slate in the brand we have our secondary also slate We have information which is then blue. We have success which is then green. We have error which is then red. Notice in your alias collections we're not assigning specific roles that are applied to components yet. We're just really just duplicating our brand and assigning it the semantic meaning. Reds are going to be errors. Greens are going to be successes. That is the alias collection. And then in your mapped collection, this is where all of your tokens start to branch out into all of these different specific use cases for components. And this is also where we handle light mode and dark mode as well, which we're also going to look at generating via AI. And I so you can sort of look at this is like with the tree examples. This is where all your tokens branch off into all these different directions where if we go back into our variables then into our maps collection you can see we have roles for surface primary surface secondary surface air surface success but then we also look at text colors as well um icon colors and then also border colors. So we're really covering all the use cases that we're going to need for our components. This is our mapped collection and then these variables are connected to our alias collection which in the alias collection are connected to our brand collection. So at a high level, these are the different types of collections that we're going to be building. But as I mentioned, we're also going to be looking at uh a responsive collection as well where we build type scales across that will work across desktop and mobile. But more to come on that a little bit later. Sorry, it's cold here. I had to put a sweater on. Um but here's a sneak preview of all the rules that we're going to build together. Couple things I would like to preface. The more you inform the AI and the more input you give it, the better the result is going to be. I'm going to go through this relatively quickly. So, I'm going to keep things a little bit high level and almost look at it from the point of view where I don't know all the different types of design tokens or variables that I'm going to want at the end of the day. Now, this is where you can watch me do this and then spend a couple hours on your own really refining how you build out the rules, some of the different types of use cases that you want in your components. Take time to do this properly. Again, I am doing this super quickly. So, at the end result, we might get some variables or tokens that we don't necessarily need. Also, too, when you're building out your um your rules, structure it. Don't just dump everything into one big paragraph, expect the AI to know exactly what's going on. But if you structure your rules in a way where it's like purpose, color rules, scale structure, other instructions, um, and sort of keep that level of naming and categorization consistent across your different collection rules, the output is always going to be much, much better. So, as I said, I'm going through this relatively quickly, but take time when you're doing this on your own to really describe the tokens that you want. If you already know all the variables that you're going to want in your collections, provide them here. You know, you don't need to be shy with the amount of information that you're going to provide the AI for your own use case. And if you are new here, we strongly recommend you watch our design system setup video. I'll put a link down below because that might provide some really good context for you. All right. Now, let's get started building out our our rules. Now, just as a preface, I do have some notes here on the lefth hand side that I'm going to be referencing just so I don't forget anything or don't lead you astray. Also, too, when I'm recording, it's kind of hard to think about exactly what to include. So, that just helps me. But, we're going to go slow. We're going to build it together. I'm going to walk you through what what I'm talking about when I talk about some of the purpose the rules and how you might want to start to structure um your rules. Then we're going to have chat GBT format our rules a little bit later on. So just know that it doesn't need to be per perfect. Okay. So starting off with our brand collection here. Let's go into our brand collection is one thing to in our brand collection. I think maybe now we'll focus on colors. when we build out a responsive um collection, we might come back and loop back to font styles and font scales and things like that. But I think just for now, we're going to focus on colors is probably why I'm going to leave out things like font style and font weight for now. Okay, so starting off with the purpose of the brand collection. Let's uh condense that in. Is the brand collection contains uh raw uh hex codes uh raw hex codes. We'll start off with that. Uh nothing in this collection uh implies uh intent role UI usage or components usage. Right? So basically sort of as we looked at earlier nothing in this is just raw codes. Nothing in here is implying which is a surface color which is a border color which is an error color which is a warning color. It's just orange scales, red scales, green scales, so on and so forth. So I think that's the purpose at a high level. Again, later on we're going to have chat GPU find some things. Now, color rules. All colors are stored as pure hex values. So as I said, pure hex values. Colors have no semantic meaning and colors are grouped uh by hue. So essentially what this is saying very similar to the purpose is they have no semantic meaning. So emerald or green in this case is not going to be success and colors are grouped by hue. So essentially again what this is saying you need to group them by scale and not just have colors floating all over the place. So then let's look at uh our scale structure. So what I mean by scale structure sort of the format for which we have colors which is this 100 scale value. If you watch some of our other design system setup videos you're going to know a little bit more about how this works. Uh but it should make some pretty common sense or should make some sense once we build out the scale structure rule here. Sorry words are tough today. Uh so scales use if I can too scales use a 100 to 1200 1 1200 scale lower number is lighter lighter. So as you can see here the lowest lower number is lighter number higher number is uh darker uh allowed increments allowed increments. So we're going to have our 100 by default. We're going to have our 50 when intermediate uh values are needed and then a 25 if uh further refinement refinement spelled that wrong. refinement uh is also needed. So what this is saying if you look here every single one of the colors tends to follow as clean like 100 value. But if we need an intimate value for things like accessibility we can insert a color in between. So in this case a color in between a 100 and 200 is a 150. And if you need a color in between a 100 and a 150 it would be a 125. So that's essentially what this is saying here. And then other instructions. Uh so if you look at white and black is in is in its own group here. So whites uh and black uh are in its own group own group called whites in black. So relatively straightforward in terms of our brand collection here. All right. So as I said before we are going to look at things like font styles, font weights, but we're not going to look at that right now. We're going to do that when we build out a responsive collection. Uh but I think our brand collection goals are relatively half decent for now. Now we're going to need to do the same for alias collection as well. So purpose of the alias collection alias tokens translates uh raw brands colors into semantic uh meaning. Sorry, let me zoom out here. Scroll down. Bring these down. Sorry, I'm trying to do both at the same time. So sorry if it's difficult to see. You might need to zoom in a little bit. But um again, just want you to see as I go go about doing it. Okay. So purpose alias tokens translate raw brand colors into semantic meaning. Uh alias is the only uh layer allowed to assign uh assign intent and group uh meaning. So essentially what I'm referring to here is it's the only collection allowed to assign specific intent at sort of the group level. So not the individual tokens, but I can see that this scale is our primary scale. This scale is our secondary scale. This scale is our information scale. So that's sort of what I'm referring to when it comes to alias are the only layer allowed to assign intent and group meaning. All right, continuing on. Uh, alias tokens must always reference brand tokens. So what this is essentially saying here is that notice how in each of the scales inside of our alias we're connecting back to that brand value. So in in the case of information we are connecting back to the blue value. What this is going to allow us to do is to maintain connectivity inside of our design tokens. So if we change one color in the brand collection everything else changes in the alias in the mapped collection. So one update updates everything else. So now we can go into our color rules. So for this essentially uh primary oops come up primary uh equals uh equals I think this is our slate um we're going to have our information uh is equal to blue. So let's scroll all the way down here. So our information is our blue. So I don't know why I did that in a separate line but uh success uh equals green. uh error uh equals red. Warning uh equals uh orange. We're going to have our neutral light and our neutral dark. So I can see here just the way that we had set things up. So we're going to have our neutral uh light equals slate as well equals slate. Our neutral dark uh equals uh gray. And then we have our foundations. Uh, and this is here is going to be our reads, uh, our whites, uh, and also, uh, our black as well. So, really just stating what the scales are that go into each and every single one. Now, I know it's self-explanatory, but it's better to inform the AI with more information than expecting it to make assumptions uh, and on its own. And just want to uh, check my notes here. Perfect. So, let's uh, continue on. So then we can also move uh in with uh not all brand scales uh must be aliased uh optional scales scales uh pro or secondary and tertiary and tertiary optional if I can spell optional right uh just again because not every brand has a secondary scale or a tertiary scale sometimes you might just have a primary scale it is something that I do see quite a bit um and then if uh brand scales exceed uh needs. Uh sort of telling the AI to pause, ask which scales should be aliased uh do not uh assume. Essentially what this is doing is if we go back here to our uh our brand collection, you're going to see that we have this grouping of secondary scales. These colors might be colors that are just applied to specific graph components. If you're working at a finance firm, sometimes you might have 15 different legend items for a graph, they're not going to always be applied to components. So essentially what this is saying is that if the brand scales exceed potential needs, pause, ask the user which scales should be aliased and do not make any hard assumptions. So now we're going to go into modes. And if you've watched any of our other videos, you're going to know that your alias collection is where you house different brands. Uh if you're a multibrand, if you have a multibrand design system, I think like Coca-Cola, Diet Coke, Coke Zero, this is where you would house um the different brands inside of modes. Again, I'll put a link down below where I cover that a little bit more in depth if you're here for the very first time. But anyways, let's continue on. So modes uh alias modes uh exist only when uh multiple brands are present are present. Um single brand design systems do not use multi-pull modes. Just the one. Just the Uh additional modes uh require uh confirmation. All right. Right. So essentially what that's saying is before it introduces another mode, maybe just the way that you have like your color scales and that you're uploading to cursor via Figma MCP might be a little bit confusing for the AI before it builds out any additional modes inside of alias is going to require confirmation from you that it's understanding. Right now let's look at our maps collection rules. This is going to be the hardest one to build rules around. And this is where it's kind of have a it's good to have a good understanding of the different types of tokens that you need because you're going to sort of specify the tokens inside of this mapped collection rule more or less. So let's start off with our purpose and token categories. Then we move into like the text rules, service rules, border rules and icon rules which can be a little bit more complex and is where the output can really vary. So starting off with the purpose of the mapped collection. So mapped tokens are the only tokens components may consume. Uh then let's look at our token categories. So our token categories are surface, text, icon, uh and also our border because these are the other key groupings. So now let's go into the rules for the individual groupings themselves. want to look at this from the point of view where if I don't necessarily know all the surface colors that I might need, all the text colors that I need, border rules and everything like that, maybe I just need a solid starting point. You don't have sort of the fundamental knowledge like I have when it comes to some of these things. So instead of defining rules at the servers level, text level, border level, icon level in that level of granularity, let's look at it from more general point of view as if you don't have that fundamental knowledge as to what goes into each of these individual rules. So let's look at a lot of our semantics here. So we have like primary, secondary, disabled, error, success, information, warning basically across all of them. So in this case our semantics are going to be our defaults, our uh sorry not our defaults, our primary, our secondary, our disabled, our error, our success, our information, our information if I can spell information right or information and also our warning. Now I do know that text also has a default and an on color. We'll get to that. All right. So um moving on to our semantics. Let's now look uh at our light and dark. So uh every maps token defines uh light value and also a a dark value. And I'm looking at accessibility. So text and icons meets contrast requirements. uh on color color uh oops I can type on color tokens are tuned for tuned for colored surfaces. So essentially what this is saying here is that if we have the text is probably the best example is if text in its own is just in an air state it's going to have a default color. But if that text is in an air state and it's on an air background it's going to need an on color value. So this is where just having some highle understanding of design tokens really helps when building this out. Uh disabled tokens uh reduce uh contrast but remain legible uh focus tokens reuse uh semantic semantic colors and then we can have um what's the word that we had before other instructions said other instructions other instructions uh I need uh tokens for the heading, hero, body, uh placeholder, caption which do not need to sit within uh a base grouping and can be inside a other group. We need on color color values for these. So essentially what this is saying is because text is a little bit unique where you need to define like the types of colors that you want for your text. You're also going to need those at the on color level as well. That's basically just what we're saying. Now I could word it better and I could go in more in depth in basically all of these but we're just getting our feet wet with this process. So now let's look at our responsive collection. And I wasn't originally going to focus on text. So I thought but I thought like why we're here already so we might as well build a responsive collection for our text as well that is going to work and also desktop and also mobile. So purpose of the responsive collection houses all responsive uh variables uh that work across uh desktop and mobile with an emphasis emphasis on type. So with this our needs what do we need? Uh text size line height line height paragraph spacing for the following. Uh so we need hero H1 uh H2 H3 H4 H5 uh H6 and then paragraph uh large medium small and then also uh our captions. So essentially this is what we're working with and then also any accessibility constraints. So accessibility constraints. So in this case um you know base paragraph size paragraph size which in this case is likely our body paragraph size uh paragraph uh medium uh needs to be uh 16 16. There we go. Because usually just like anything below 16 is where you need to be careful with accessibility. So there we go. There we have our responsive collection rules. But if we go back and actually think about uh where we're going to need our type styles. So usually where this is housed is also inside of your brand collection. So your font style if we go back to our brand collection rules. Um so called white black. Other instructions uh font style, style and scale, font style and weights. Uh font styles are included uh included as string variables. String variables. Font weights are also included as string variables. As string variables, this would be inside of your brand collection. And then other instructions inside of our alias collection is if they are multiple brands uh needed for your font style and your font weights, font weights and styles uh can be pulled into alias if multiple brands are required. Again, go watch our design system setup video if you're curious around like the logistics behind that. explains a little bit more in depth. But now also by at the end of this we're also going to be able to get a responsive collection that is going to be able to build out a responsive type scale for us. So this process you're going to do for each of the different collections that we built highle rules for. So essentially what I had to do is study the proper format of a cursor rules for a MBC file. What that is you're going to see in just a second. So I went through and studied everything and then uh what I did is I just provided a screenshot of the rules like a screenshot just need to copy all the individual text one by one and had it like build a formatted rule based on this. So really easy prompting and it returned sort of this output here. So, what we're going to do, we're going to copy this code here. Do the same for our alias collection, maps collection, also responsive collection, and then navigate back into uh cursor to build out those individual rules. So, here I am just in like an empty cursor workspace or cursor project that I saved on my desktop. I called it tokens. You can call it UI collector tutorial. You can call it whatever you want. So you're going to come up here uh to settings and under rules and commands we're going to add a project rule because again these rules going to be specific to this project itself not across every project. So let's add a custom rule and call this you know brand collection. There we go. And then just paste in uh the rest of the prompt that we got um from chat GBT. Save this. If we navigate back to rules and commands we can see there's not any issues with it. If there are issues with it, uh, cursor will call that out for you. Now, let's do the same for alias collection, mapped collection, and also our responsive collection. Okay, what's going on? New day, new fit. These things take forever for me to film, so sometimes I look different because I film it on different days. Anyways, let's continue on. So, what you should have done by now is you should have taken the output that GPT gave you. Now, we're all going to get different outputs. So, it doesn't really matter what's in mind because it sort of led you to water by now. So, you should have some type of result. And as I said before, the more you prep uh AI with when it comes to the rules, like the more information you put down in each of the rules, the better output you're going to get. Again, I'm doing this for a tutorial, so we're not diving in super in-depth. Maybe I might do that in a future video. Who knows? Comment below if you want to see that. But if we go to our oops, sorry, had on the wrong web here. There we go. Uh so if you go to the responsive collection here I'm not going to look over the map to the brand collection just the output that it gave us. So if you go to the responsive collection here again with the responsive collection we're focusing on typography. Now this is where again the better more information you give the AI the better the output is going to be the first time. Now if you want the AI to also generate your displays and headings what do we need to give it? What type of font do we need? That's generally the basics uh of what we would need to include to get the best output the first time or else what it might do is it might give us enter for headings robboto for paragraph and we want everything to be enter. So what we can do we can look inside our rule here make some tweaks uh consumption rules avoid hardcoded components must uh variables for typography behavior uh I'm trying to look at the best place in order to put consistency rules probably see it probably the best place to put it. So, typography scaling must preserve line heights must uh and what we can do here is uh fonts must and then just all be in uh enter uh font. So hopefully what that will do is actually just give us enter for all across all of our headings and all of our paragraphs and so on and so forth. So again, as you generate rules, go through and audit it. You might need to make tweaks if you want to, but we're not going to go through and do that uh right now. But I think we have our rules in a pretty good spot. So, we have rules for our alias collection, brand collection, map collection, responsible collection. Now, what a lot of designers do when they're working with AI, especially within cursor, is they might just come here and say, "Generate me the design tokens." Like a really simple design tokens. There we go. Like a really simple prompt. Now, prompt engineering is kind of a thing. You see a ton of rules out there for prompt engineers, especially at places like Google, so on and so forth. So, if we just put in generate me the design tokens based on the rules, based on the rules, it's not going to give us a really good output because it's going to go through the rules, but do you need to build the alias collection first or the mapped collection? What's the order in which I should apply these things? Are there other things that the AI should take into consideration when building out the design tokens? So, whenever you're working on really more complex asks, break it out. You can build a specific command around some of these more complex asks. So, even if I need to reuse this in the future, whereas maybe I made a mistake and I want to duplicate this workspace and and start from scratch with new rules, I can just keep running the same command over and over and over again until I get the most optimal output. AI is not at a point where you get the best result the first time. You might need to do this a couple times. Tweak the rules, see the output, tweak things to really get what it is that you're looking for. So instead of just running a really simple command like that, one thing we're going to do now is we're going to build out an actual command that we can reuse and call within cursor other AI tools if we were to put it in there uh over and over and over again that we can reuse. Um so let's focus on that. then lets you import our scales and then run the command and build our tokens. So, what we're gonna do, we're g to go up into our settings here. We're going to go down to sorry, rules and emax and we are going to add uh a project command that we're just going to call token um generation command. Doesn't really matter what you call it. And then there we go. Now, what we're going to do, this is essentially building a reusable command. Now, forgive me as I do have uh a more completed command uh on this side over here, but I just wanted to write it out so you you'd have to see me waste a bunch of time thinking about right what to write. Okay, so I'm be looking here uh as a reference point, but we want to build out this command uh together. So, right away uh generate uh a complete design token system using the provided uh inputs. So what I say by provided inputs is one thing we're going to do. We're actually going to feed it feed the AI our scales in our design systems. Just raw scales, you know, things that you probably built hundred times before that you probably already have floating around. If you don't have color scales, just use a color scale generator to build them out for you. It's not something you would need this level of complexity to build for you because there's tools out there that will already do it much easier and faster. So if you just go on Figma color scale generator, there's a ton of different tools online. Search it up, generate some scales if you really need to. Okay, let's keep moving forward. So generate a complete design token system using the inputs provided. So then we're going to go into our steps. Uh so step number one is ensure you have a understanding of the color scales uh provided. Uh ask clarifying questions if needed. Uh oops. And then let's go number two. uh generate a brand collection uh using the raw scales provided. Step number three uh generate uh an alias collection uh mapping brand colors to semantic roles. So semantic roles like error, success, those kinds of things. Uh number four uh generate a maps collection using uh or including sorry including and then we can add sort of points underneath it here uh surface uh text uh icon uh and border categories. So these are the ones that we looked at uh before uh all semantic intents. So this is where we get into things like surface uh default that kind of thing. All semantic intents, all interaction states, so things like hover, focus, so on and so forth. Uh explicit light and dark uh values. Uh there we go. I think we're in some pretty good shape there. So now step number five uh generate responsive typography uh tokens for all text styles um six ensure no mapped token references uh brand values directly. So essentially what this is saying is that it needs to go to an alias to connect properly. Uh and then number seven, uh output a single JSON file file compatible with tokens studio studio uh import. So we're going to be using token studio, which is a really common tool out there. Figma does have an import feature. They do have one, but it does not work when it comes to connecting different collections. It's good if you're just throwing everything into one collection, not when you need to connect things back to multiple collections. I'm sure they're going to get there in the future. When they do, I'll film another video and we can go through this again or something similar again to go through that together. But as of right now, and I have chat with my developer friends, um people in expert and Figma 2 and there's no way to import tokens across different collections all with within once. You would have to go back and manually connect things. So that's why we're using token studio eight. Uh do not invent uh values infer meaning or auto uh correct contrast again for if you really need this one or not. If uh required input is missing pause and request uh clarification. Uh spelled clarification wrong. I think I still spelled it wrong. What? whatever um return only only the final JSON output. So what we have here now is we actually have a command that we can actually reuse. So let's go to our rules and commands. So I can see it's there. So now uh if I go back here, we want to call this in the future. What we can actually do is see how it comes up here at token generation command. We can just hit something like run. Then what it's going to do, it's going to read everything in the command. go through, look at the rules, make inferences based on which rules need to be applied when, and actually build out that token set for you. So, we're in a pretty decent spot now. Now, for your colors, ideally, you should have something like this. As I said before, you don't need to have AI build out scales for you. I mean, you can if you want to, then you kind of lose some of the control. Just Google color scale generator Figma import, and there's a million of tools and plugins that'll probably come up that will generate scales for you. and then you can import them to Figma. Just do that. It's going to make your life super duper easy. Uh, but I just have my scales here formatted. We're only going to focus on sort of the primary colors. Not going to worry about all the secondary colors and everything like that for this tutorial. Maybe in a future, but essentially what we have here, we have our slate uh used for primary and secondary. It's just based off this design system. Red for error, blue for information, orange for warning, green for um, uh, success. you know this gray for miscellaneous so on and so forth. So what we are going to do is have your scales in some type of format like this that you can easily copy ideally with nothing else on the page. So you can see here I have my tokens where I have like secondary colors um you know a full list of all the actual tokens that I want uh to have. Again we're not going to you likely don't have this. So anyways let's just go back here. So separate it out just the colors that you want to use and then what you are going to do is just simply select copy this. So I'm just copying the frame itself. So you can go copy as oops uh copy link to selection and then because we had connected Figma MCP to curse a little bit later on cursor and AI can actually understand what is going on on this Figma page and read this Figma file itself to pull in the color scales that we have. So now within cursor because we already have this prompt all the instructions we want don't we we want it to follow we don't need to write it out here. So what we can do is maybe just uh here are the uh color scales something like this. Uh and then because we're already calling this command. Now what we can do is just run it. Let's just see what happens. Maybe I probably could have gone a little bit more in depth with that prompt prompt here. But let's have some fun with it, shall we? So I can see it's running the MCP tool. It's doing all this fun stuff. This is where I might pause the video and wait a little bit until it comes back with something. Perfect. So, it's see notice how it's reading the scales. It noticed them and that's because we connected MCP. So, it's going through and doing some things. So, what it did is it came back with a couple clarifying questions again because we had it like told it to request clarification if it wasn't sure. So, had a question around white and black um semantic meaning uh typography. Now, I made a mistake because in the actual Figma file I was using, the text that was on the page was already using enter. Sorry, that's one of that one's on me. So, it just had a question relating to that. And then it asked for interaction states. Now, this is where if we took a lot a little bit more time in the actual rule, you know, it wouldn't need to ask for things like this, but essentially it's asking if we need a hover, pressed, focus, and default uh and disabled. So, sorry, it's asking if we need interaction states like hover, pressed, and focus in addition to default and disabled. But pressed and focus are kind of the same thing. So I just put press does not needed just simple questions there. So it might come back and ask you for some clarifying questions on some things. And now as you can see here it's generating the the JSON file that will be compatible with token studio in their token import because their token import works 100 million times better than thickness native token import right now when it comes to connecting tokens across multiple collections. Flip my hat around because I realized that the shiny thing in the back was sparkling in the light. Anyways, um so what I meant is that like this import functionality, it doesn't work when you need your tokens to connect to each other across collections to have your brand collections be your ali your your mapped tokens to connect to your alias tokens to connect to your brand tokens or if you're using a two-tiered approach for your semantic tokens to connect to your primitive tokens. It doesn't work well when you're importing tokens across multiple collections. is great if you're just importing everything in one collection, but it's just not there yet. Might get there sooner, but it's not there right now, which is why we're going to be using Tokens Studio plugin. Now, look what it's came up with. An entire JSON file of our design tokens. Now, I haven't tested this yet, so I don't know if it got it right first time, but just based off of the limited amount that we put into the rules, it went through and actually generated everything for us. So, we can see here we have paragraph spacing, font size, line heights, uh different type styles. Then we get into our border. So, default, subtle. I see a couple things here that I don't like that I would have to change, but primary, default, hover, focus, disabled, subtle, subtle, hover, all the different semantics that we provided in the rules. It looks to have generated some tokens for us um across light mode and dark mode which is great. Now again you're going to have to refine this a little bit. You're never going to get it right first time. The more you give the rules the better the output is going to be. Now also do you need to think about this from like a personal brand perspective and a collaboration with your developers perspective is you just generated a JSON file of the design tokens that you want to use in your design system. That's a flex. You show this in an interview, foot in the door, you hand this off to your developers, they love you instantly, right? So, what we're going to do here is if on cursor, if you come up here to file, I don't know if you're going to be able to see it. No, you won't be able to see it, but file and then save as, just save this specific uh JSON file somewhere. Call it anything. I'm not going to do it with you because you're going to see my messy files on my desktop and on my computer, and I don't want you to have to see that. So, just hit file, save as, and save this specific JSON file anywhere. And then what we're going to do, we're going to flip back to Figma. Now, one thing we're going to be needing, as I said before, is Token Studio for Figma because their token import works way better than Figma variables. Right now, if you just search Token Studio on the Figma community, it is probably going to be the first thing that comes up. Fun fact for you, Figma Variables is actually based off of Token Studio. Token Studio is the original when it came to handling design tokens within Figma. It's also too one of the reasons why Figma got so popular is allowed companies to manage their design tokens within Figma. So anyways, token studio. So just hit new empty file, then come down here and hit load from file and folder. And then select that JSON file that you've saved on your desktop. Again, we're not doing it together because then you're going to see my messy file structure that I have on my desktop. So just hit load from file folder and select the file and then it will it will import. So now with the JSON file loaded, look what we have here is we have sort of the foundation of our design tokens. Now one thing we do I'm just going to turn all these on at once. Brand alias uh mapped and then also responsive. Um so I can see here in our brand we have our font family. So we have inter paragraph, inter for heading as we called out in that command or the rules or whatever it is we put it. We also have font weights which is perfect. Inside the brand collection, we have all of our color scales here, which appear to be accurate based on what we imported via Thigma MCP. Now, if we come down here to responsive, we'll get to alias in just a sec. It looks like we also have our line heights and our font sizes for all of our different um typography, even our paragraph spacing, too. This is looking really, really good. Now, what's one thing that we noticed here is if we click into alias, it looks like something's actually broken in the JSON file where it's not connecting back to brand properly. And this is what I mean by you're never going to get it right first time. You're gonna need to dialogue with the AI a little bit, especially when it comes to like outputting the JSON file. Um, so what I'm going to do here is I'm actually just going to take a screenshot of what I'm seeing here to give cursor as a reference point to show that something is broken when connecting back into the different collections. So now let's navigate back to cursor and provide it feedback. So I just provided a screenshot that I took there of token studio where it showed like the tokens are broken. So it just said brand collection looks good but it appears something is broken in the alias maps collection as the tokens appear to not be connecting properly. Please reference screenshot. So let's enter that and just see what it comes back with. So I just went through the same process that we did before of importing uh the JSON or saving the JSON file from from cursor and uploading it to token studio. And now look what uh we have here. So we have our brand collection but now we also have our alias collection and then we also have our light mode and then also our dark mode. Look at that. We have successfully vibe coded some tokens. Now if we look at this too we also have different modes I guess for uh mobile and desktop type scales. Look at that. Pretty impressive, right? So this looks pretty good. So I'm going to go ahead toggle all of these on. Uh, and now what we're going to do, we're going to start to sync this to our Figma variables now that everything appears to be connected and there's no break within our tokens within Token Studio. So, I'm going to come here to styles and variables. And the beauty of this is you don't need to be on the pro version of Token Studio. It's out of the box. So, we're going to go to export styles and variables to Figma and just confirm everything as it is right here. And then what we're going to do, we're going to go into your token sets. Now, one thing you might need to do is sometimes what comes in here and everything automatically is disabled just like this. So, it's going to show or it should have showed like zero of six sets selected for export. Um, but you can see here that mine are already enabled. Just make sure all of these are set to enabled and it's showing here six of six sets or however many sets you have selected for export and it's not zero of six. If it's zero of six, you need to come in here and set these to enabled. So then just come in here and confirm and then let's go into our tokens here or what happened or export to Figma. There we go. So I can see it's creating the variables. Six collections and 563 variables created. Beautiful. Let's come in here. Look at this. We actually have our design tokens. Now look at this. Absolutely awesome. I can see here they're also connected back uh to the brand collection. And I see we also have uh the tokens for our mapped collection as well. Now, we would need to come in here and polish things up, make sure all of our tokens are covered, but it gives us like a really great starting point without having to do a lot of the manual linking and the manual building. Now, what's one thing that we notice here right away is that something is broken because we have mapped light and then mapped dark as two separate collections. But we don't want that to happen, do we? And that's the same with responsive desktop and mobile. We want everything responsive to be in one collection and mapped light and dark to be inside one collection as well because that makes things easier to apply and easier to mode swap. So we can actually do that just within Figma variables. Let's take a look at how. So come into any one of these collections where they're separated. So like dark or light or whatever it is. So we're going to be on dark cuz I always want that to be like my second mode. It's usually how I like to structure things. So what I'm going to do, I'm going to two-finger tap on this mode. And you can see here now this sort of thing pops up where you can duplicate the mode, import a mode, or export a mode. What we're going to do, we're going to hit export a mode. And again, I'm not going to hit that with you because then you're going to see my messy file structure. So, we're just going to on your own just export the mode and then come into the other maps light and then add another mode. And then what you're going to do here is you're going to hit import. So, what I've done here is I've just cleaned things up. So, I imported the dark mode and just got rid of one mapped collection and called this other one mapped. and did the same with the responsive collection as well. So sort of just combined the different the collections and just got rid of the separate collection for each of them. So now we have the ability here to if I was to go ahead just add in a quick frame and then just add in uh this rectangle and if we were to apply like a surface you know uh default and then if we were to go ahead and simply uh swap the mode so I can see it's on light. Uh if we were to change this to dark we can see that changes accordingly. So everything is looking good. So as you can see we have successfully vibecoded a complete design system Figma variable set using cursor. Brilliant. We have our brand collection. We have our alias collection. We have our mapped collection. We have a responsive collection. One thing I would like to call out is there might be some bugs here still. So if I was to go down to maybe it's our brand or maybe our mapped is we generally don't have typography like this in our mapped collection. It's generally more in the alias collection more than anything because they wouldn't need to toggle between light and dark. they should just be the same across light mode and dark mode. So this is where you need to sort of do an audit. You can dialogue with cursor a little bit more. Make sure it gets the output the very first time, but it's things that are relatively easy to clean up. And you can see there some things off in the string variables here too. You can easily copy these variables and bring them into the alias collection uh where required. Uh and you might need to do some relinking, but for the most part AI successfully done about, you know, 85 90% of the work. And again, of course, we'd have to go through and audit everything to make sure that the variables are up to par and it matches what we want to go through in terms of our design system. But more often than not, or more or less, we have really vibe coded a complete thing variable set for a design system. Rock and roll. And thanks for being here. If you want to watch a video I highly recommend where we build an entire design system, click right there. And if you want to watch another video on vibe coding, click right there.
