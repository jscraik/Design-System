import{f as A,j as Ye,Q as Xe,O as ve,P as ne,M as $,k as Q,g as x,l as At,m as It,U as z,c as w,D as Nt,n as Ot,o as Ft,p as zt,q as N,r as me,s as kt,C as rt,t as ge,F as Lt,u as Z,E as Ce,L as nt,v as at,w as h,S as qe,x as Ht,y as he,z as de,G as O,I as Gt,J as k,K as ot,X as lt,Y as ct,Z as Vt,_ as jt,$ as $e,a0 as Qe}from"./vendor-three-core-D4EdNJXX.js";var Wt=Object.defineProperty,Kt=(e,t,i)=>t in e?Wt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Zt=(e,t,i)=>(Kt(e,t+"",i),i);class Yt{constructor(){Zt(this,"_listeners")}addEventListener(t,i){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(i)===-1&&s[t].push(i)}hasEventListener(t,i){if(this._listeners===void 0)return!1;const s=this._listeners;return s[t]!==void 0&&s[t].indexOf(i)!==-1}removeEventListener(t,i){if(this._listeners===void 0)return;const n=this._listeners[t];if(n!==void 0){const a=n.indexOf(i);a!==-1&&n.splice(a,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const s=this._listeners[t.type];if(s!==void 0){t.target=this;const n=s.slice(0);for(let a=0,o=n.length;a<o;a++)n[a].call(this,t);t.target=null}}}var Xt=Object.defineProperty,qt=(e,t,i)=>t in e?Xt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,d=(e,t,i)=>(qt(e,typeof t!="symbol"?t+"":t,i),i);const fe=new At,Je=new It,$t=Math.cos(70*(Math.PI/180)),et=(e,t)=>(e%t+t)%t;class Si extends Yt{constructor(t,i){super(),d(this,"object"),d(this,"domElement"),d(this,"enabled",!0),d(this,"target",new A),d(this,"minDistance",0),d(this,"maxDistance",1/0),d(this,"minZoom",0),d(this,"maxZoom",1/0),d(this,"minPolarAngle",0),d(this,"maxPolarAngle",Math.PI),d(this,"minAzimuthAngle",-1/0),d(this,"maxAzimuthAngle",1/0),d(this,"enableDamping",!1),d(this,"dampingFactor",.05),d(this,"enableZoom",!0),d(this,"zoomSpeed",1),d(this,"enableRotate",!0),d(this,"rotateSpeed",1),d(this,"enablePan",!0),d(this,"panSpeed",1),d(this,"screenSpacePanning",!0),d(this,"keyPanSpeed",7),d(this,"zoomToCursor",!1),d(this,"autoRotate",!1),d(this,"autoRotateSpeed",2),d(this,"reverseOrbit",!1),d(this,"reverseHorizontalOrbit",!1),d(this,"reverseVerticalOrbit",!1),d(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),d(this,"mouseButtons",{LEFT:$.ROTATE,MIDDLE:$.DOLLY,RIGHT:$.PAN}),d(this,"touches",{ONE:Q.ROTATE,TWO:Q.DOLLY_PAN}),d(this,"target0"),d(this,"position0"),d(this,"zoom0"),d(this,"_domElementKeyEvents",null),d(this,"getPolarAngle"),d(this,"getAzimuthalAngle"),d(this,"setPolarAngle"),d(this,"setAzimuthalAngle"),d(this,"getDistance"),d(this,"getZoomScale"),d(this,"listenToKeyEvents"),d(this,"stopListenToKeyEvents"),d(this,"saveState"),d(this,"reset"),d(this,"update"),d(this,"connect"),d(this,"dispose"),d(this,"dollyIn"),d(this,"dollyOut"),d(this,"getScale"),d(this,"setScale"),this.object=t,this.domElement=i,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>f.phi,this.getAzimuthalAngle=()=>f.theta,this.setPolarAngle=r=>{let c=et(r,2*Math.PI),p=f.phi;p<0&&(p+=2*Math.PI),c<0&&(c+=2*Math.PI);let E=Math.abs(c-p);2*Math.PI-E<E&&(c<p?c+=2*Math.PI:p+=2*Math.PI),m.phi=c-p,s.update()},this.setAzimuthalAngle=r=>{let c=et(r,2*Math.PI),p=f.theta;p<0&&(p+=2*Math.PI),c<0&&(c+=2*Math.PI);let E=Math.abs(c-p);2*Math.PI-E<E&&(c<p?c+=2*Math.PI:p+=2*Math.PI),m.theta=c-p,s.update()},this.getDistance=()=>s.object.position.distanceTo(s.target),this.listenToKeyEvents=r=>{r.addEventListener("keydown",_e),this._domElementKeyEvents=r},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",_e),this._domElementKeyEvents=null},this.saveState=()=>{s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=()=>{s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(n),s.update(),u=l.NONE},this.update=(()=>{const r=new A,c=new A(0,1,0),p=new Xe().setFromUnitVectors(t.up,c),E=p.clone().invert(),B=new A,L=new Xe,j=2*Math.PI;return function(){const Ze=s.object.position;p.setFromUnitVectors(t.up,c),E.copy(p).invert(),r.copy(Ze).sub(s.target),r.applyQuaternion(p),f.setFromVector3(r),s.autoRotate&&u===l.NONE&&Te(mt()),s.enableDamping?(f.theta+=m.theta*s.dampingFactor,f.phi+=m.phi*s.dampingFactor):(f.theta+=m.theta,f.phi+=m.phi);let H=s.minAzimuthAngle,G=s.maxAzimuthAngle;isFinite(H)&&isFinite(G)&&(H<-Math.PI?H+=j:H>Math.PI&&(H-=j),G<-Math.PI?G+=j:G>Math.PI&&(G-=j),H<=G?f.theta=Math.max(H,Math.min(G,f.theta)):f.theta=f.theta>(H+G)/2?Math.max(H,f.theta):Math.min(G,f.theta)),f.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,f.phi)),f.makeSafe(),s.enableDamping===!0?s.target.addScaledVector(M,s.dampingFactor):s.target.add(M),s.zoomToCursor&&oe||s.object.isOrthographicCamera?f.radius=xe(f.radius):f.radius=xe(f.radius*S),r.setFromSpherical(f),r.applyQuaternion(E),Ze.copy(s.target).add(r),s.object.matrixAutoUpdate||s.object.updateMatrix(),s.object.lookAt(s.target),s.enableDamping===!0?(m.theta*=1-s.dampingFactor,m.phi*=1-s.dampingFactor,M.multiplyScalar(1-s.dampingFactor)):(m.set(0,0,0),M.set(0,0,0));let se=!1;if(s.zoomToCursor&&oe){let ie=null;if(s.object instanceof ne&&s.object.isPerspectiveCamera){const re=r.length();ie=xe(re*S);const ue=re-ie;s.object.position.addScaledVector(Be,ue),s.object.updateMatrixWorld()}else if(s.object.isOrthographicCamera){const re=new A(V.x,V.y,0);re.unproject(s.object),s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/S)),s.object.updateProjectionMatrix(),se=!0;const ue=new A(V.x,V.y,0);ue.unproject(s.object),s.object.position.sub(ue).add(re),s.object.updateMatrixWorld(),ie=r.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),s.zoomToCursor=!1;ie!==null&&(s.screenSpacePanning?s.target.set(0,0,-1).transformDirection(s.object.matrix).multiplyScalar(ie).add(s.object.position):(fe.origin.copy(s.object.position),fe.direction.set(0,0,-1).transformDirection(s.object.matrix),Math.abs(s.object.up.dot(fe.direction))<$t?t.lookAt(s.target):(Je.setFromNormalAndCoplanarPoint(s.object.up,s.target),fe.intersectPlane(Je,s.target))))}else s.object instanceof ve&&s.object.isOrthographicCamera&&(se=S!==1,se&&(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/S)),s.object.updateProjectionMatrix()));return S=1,oe=!1,se||B.distanceToSquared(s.object.position)>v||8*(1-L.dot(s.object.quaternion))>v?(s.dispatchEvent(n),B.copy(s.object.position),L.copy(s.object.quaternion),se=!1,!0):!1}})(),this.connect=r=>{s.domElement=r,s.domElement.style.touchAction="none",s.domElement.addEventListener("contextmenu",We),s.domElement.addEventListener("pointerdown",Ve),s.domElement.addEventListener("pointercancel",te),s.domElement.addEventListener("wheel",je)},this.dispose=()=>{var r,c,p,E,B,L;s.domElement&&(s.domElement.style.touchAction="auto"),(r=s.domElement)==null||r.removeEventListener("contextmenu",We),(c=s.domElement)==null||c.removeEventListener("pointerdown",Ve),(p=s.domElement)==null||p.removeEventListener("pointercancel",te),(E=s.domElement)==null||E.removeEventListener("wheel",je),(B=s.domElement)==null||B.ownerDocument.removeEventListener("pointermove",Me),(L=s.domElement)==null||L.ownerDocument.removeEventListener("pointerup",te),s._domElementKeyEvents!==null&&s._domElementKeyEvents.removeEventListener("keydown",_e)};const s=this,n={type:"change"},a={type:"start"},o={type:"end"},l={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let u=l.NONE;const v=1e-6,f=new Ye,m=new Ye;let S=1;const M=new A,C=new x,R=new x,I=new x,y=new x,_=new x,D=new x,F=new x,X=new x,ee=new x,Be=new A,V=new x;let oe=!1;const b=[],le={};function mt(){return 2*Math.PI/60/60*s.autoRotateSpeed}function Y(){return Math.pow(.95,s.zoomSpeed)}function Te(r){s.reverseOrbit||s.reverseHorizontalOrbit?m.theta+=r:m.theta-=r}function Ue(r){s.reverseOrbit||s.reverseVerticalOrbit?m.phi+=r:m.phi-=r}const ye=(()=>{const r=new A;return function(p,E){r.setFromMatrixColumn(E,0),r.multiplyScalar(-p),M.add(r)}})(),Ae=(()=>{const r=new A;return function(p,E){s.screenSpacePanning===!0?r.setFromMatrixColumn(E,1):(r.setFromMatrixColumn(E,0),r.crossVectors(s.object.up,r)),r.multiplyScalar(p),M.add(r)}})(),q=(()=>{const r=new A;return function(p,E){const B=s.domElement;if(B&&s.object instanceof ne&&s.object.isPerspectiveCamera){const L=s.object.position;r.copy(L).sub(s.target);let j=r.length();j*=Math.tan(s.object.fov/2*Math.PI/180),ye(2*p*j/B.clientHeight,s.object.matrix),Ae(2*E*j/B.clientHeight,s.object.matrix)}else B&&s.object instanceof ve&&s.object.isOrthographicCamera?(ye(p*(s.object.right-s.object.left)/s.object.zoom/B.clientWidth,s.object.matrix),Ae(E*(s.object.top-s.object.bottom)/s.object.zoom/B.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}})();function Ee(r){s.object instanceof ne&&s.object.isPerspectiveCamera||s.object instanceof ve&&s.object.isOrthographicCamera?S=r:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function ce(r){Ee(S/r)}function be(r){Ee(S*r)}function Ie(r){if(!s.zoomToCursor||!s.domElement)return;oe=!0;const c=s.domElement.getBoundingClientRect(),p=r.clientX-c.left,E=r.clientY-c.top,B=c.width,L=c.height;V.x=p/B*2-1,V.y=-(E/L)*2+1,Be.set(V.x,V.y,1).unproject(s.object).sub(s.object.position).normalize()}function xe(r){return Math.max(s.minDistance,Math.min(s.maxDistance,r))}function Ne(r){C.set(r.clientX,r.clientY)}function gt(r){Ie(r),F.set(r.clientX,r.clientY)}function Oe(r){y.set(r.clientX,r.clientY)}function St(r){R.set(r.clientX,r.clientY),I.subVectors(R,C).multiplyScalar(s.rotateSpeed);const c=s.domElement;c&&(Te(2*Math.PI*I.x/c.clientHeight),Ue(2*Math.PI*I.y/c.clientHeight)),C.copy(R),s.update()}function Tt(r){X.set(r.clientX,r.clientY),ee.subVectors(X,F),ee.y>0?ce(Y()):ee.y<0&&be(Y()),F.copy(X),s.update()}function Et(r){_.set(r.clientX,r.clientY),D.subVectors(_,y).multiplyScalar(s.panSpeed),q(D.x,D.y),y.copy(_),s.update()}function bt(r){Ie(r),r.deltaY<0?be(Y()):r.deltaY>0&&ce(Y()),s.update()}function xt(r){let c=!1;switch(r.code){case s.keys.UP:q(0,s.keyPanSpeed),c=!0;break;case s.keys.BOTTOM:q(0,-s.keyPanSpeed),c=!0;break;case s.keys.LEFT:q(s.keyPanSpeed,0),c=!0;break;case s.keys.RIGHT:q(-s.keyPanSpeed,0),c=!0;break}c&&(r.preventDefault(),s.update())}function Fe(){if(b.length==1)C.set(b[0].pageX,b[0].pageY);else{const r=.5*(b[0].pageX+b[1].pageX),c=.5*(b[0].pageY+b[1].pageY);C.set(r,c)}}function ze(){if(b.length==1)y.set(b[0].pageX,b[0].pageY);else{const r=.5*(b[0].pageX+b[1].pageX),c=.5*(b[0].pageY+b[1].pageY);y.set(r,c)}}function ke(){const r=b[0].pageX-b[1].pageX,c=b[0].pageY-b[1].pageY,p=Math.sqrt(r*r+c*c);F.set(0,p)}function Mt(){s.enableZoom&&ke(),s.enablePan&&ze()}function _t(){s.enableZoom&&ke(),s.enableRotate&&Fe()}function Le(r){if(b.length==1)R.set(r.pageX,r.pageY);else{const p=Re(r),E=.5*(r.pageX+p.x),B=.5*(r.pageY+p.y);R.set(E,B)}I.subVectors(R,C).multiplyScalar(s.rotateSpeed);const c=s.domElement;c&&(Te(2*Math.PI*I.x/c.clientHeight),Ue(2*Math.PI*I.y/c.clientHeight)),C.copy(R)}function He(r){if(b.length==1)_.set(r.pageX,r.pageY);else{const c=Re(r),p=.5*(r.pageX+c.x),E=.5*(r.pageY+c.y);_.set(p,E)}D.subVectors(_,y).multiplyScalar(s.panSpeed),q(D.x,D.y),y.copy(_)}function Ge(r){const c=Re(r),p=r.pageX-c.x,E=r.pageY-c.y,B=Math.sqrt(p*p+E*E);X.set(0,B),ee.set(0,Math.pow(X.y/F.y,s.zoomSpeed)),ce(ee.y),F.copy(X)}function Rt(r){s.enableZoom&&Ge(r),s.enablePan&&He(r)}function wt(r){s.enableZoom&&Ge(r),s.enableRotate&&Le(r)}function Ve(r){var c,p;s.enabled!==!1&&(b.length===0&&((c=s.domElement)==null||c.ownerDocument.addEventListener("pointermove",Me),(p=s.domElement)==null||p.ownerDocument.addEventListener("pointerup",te)),Ut(r),r.pointerType==="touch"?Ct(r):Dt(r))}function Me(r){s.enabled!==!1&&(r.pointerType==="touch"?Bt(r):Pt(r))}function te(r){var c,p,E;yt(r),b.length===0&&((c=s.domElement)==null||c.releasePointerCapture(r.pointerId),(p=s.domElement)==null||p.ownerDocument.removeEventListener("pointermove",Me),(E=s.domElement)==null||E.ownerDocument.removeEventListener("pointerup",te)),s.dispatchEvent(o),u=l.NONE}function Dt(r){let c;switch(r.button){case 0:c=s.mouseButtons.LEFT;break;case 1:c=s.mouseButtons.MIDDLE;break;case 2:c=s.mouseButtons.RIGHT;break;default:c=-1}switch(c){case $.DOLLY:if(s.enableZoom===!1)return;gt(r),u=l.DOLLY;break;case $.ROTATE:if(r.ctrlKey||r.metaKey||r.shiftKey){if(s.enablePan===!1)return;Oe(r),u=l.PAN}else{if(s.enableRotate===!1)return;Ne(r),u=l.ROTATE}break;case $.PAN:if(r.ctrlKey||r.metaKey||r.shiftKey){if(s.enableRotate===!1)return;Ne(r),u=l.ROTATE}else{if(s.enablePan===!1)return;Oe(r),u=l.PAN}break;default:u=l.NONE}u!==l.NONE&&s.dispatchEvent(a)}function Pt(r){if(s.enabled!==!1)switch(u){case l.ROTATE:if(s.enableRotate===!1)return;St(r);break;case l.DOLLY:if(s.enableZoom===!1)return;Tt(r);break;case l.PAN:if(s.enablePan===!1)return;Et(r);break}}function je(r){s.enabled===!1||s.enableZoom===!1||u!==l.NONE&&u!==l.ROTATE||(r.preventDefault(),s.dispatchEvent(a),bt(r),s.dispatchEvent(o))}function _e(r){s.enabled===!1||s.enablePan===!1||xt(r)}function Ct(r){switch(Ke(r),b.length){case 1:switch(s.touches.ONE){case Q.ROTATE:if(s.enableRotate===!1)return;Fe(),u=l.TOUCH_ROTATE;break;case Q.PAN:if(s.enablePan===!1)return;ze(),u=l.TOUCH_PAN;break;default:u=l.NONE}break;case 2:switch(s.touches.TWO){case Q.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;Mt(),u=l.TOUCH_DOLLY_PAN;break;case Q.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;_t(),u=l.TOUCH_DOLLY_ROTATE;break;default:u=l.NONE}break;default:u=l.NONE}u!==l.NONE&&s.dispatchEvent(a)}function Bt(r){switch(Ke(r),u){case l.TOUCH_ROTATE:if(s.enableRotate===!1)return;Le(r),s.update();break;case l.TOUCH_PAN:if(s.enablePan===!1)return;He(r),s.update();break;case l.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;Rt(r),s.update();break;case l.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;wt(r),s.update();break;default:u=l.NONE}}function We(r){s.enabled!==!1&&r.preventDefault()}function Ut(r){b.push(r)}function yt(r){delete le[r.pointerId];for(let c=0;c<b.length;c++)if(b[c].pointerId==r.pointerId){b.splice(c,1);return}}function Ke(r){let c=le[r.pointerId];c===void 0&&(c=new x,le[r.pointerId]=c),c.set(r.pageX,r.pageY)}function Re(r){const c=r.pointerId===b[0].pointerId?b[1]:b[0];return le[c.pointerId]}this.dollyIn=(r=Y())=>{be(r),s.update()},this.dollyOut=(r=Y())=>{ce(r),s.update()},this.getScale=()=>S,this.setScale=r=>{Ee(r),s.update()},this.getZoomScale=()=>Y(),i!==void 0&&this.connect(i),this.update()}}var we=1/1e3,Qt=1e3,Jt=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(e){typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=e)}get delta(){return this._delta*we}get fixedDelta(){return this._fixedDelta*we}set fixedDelta(e){this._fixedDelta=e*Qt}get elapsed(){return this._elapsed*we}update(e){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(e!==void 0?e:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(e){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},es=(()=>{const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]),i=new jt;return i.setAttribute("position",new $e(e,3)),i.setAttribute("uv",new $e(t,2)),i})(),U=class Pe{static get fullscreenGeometry(){return es}constructor(t="Pass",i=new qe,s=new ve){this.name=t,this.renderer=null,this.scene=i,this.camera=s,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(t){if(this.rtt===t){const i=this.fullscreenMaterial;i!==null&&(i.needsUpdate=!0),this.rtt=!t}}set mainScene(t){}set mainCamera(t){}setRenderer(t){this.renderer=t}isEnabled(){return this.enabled}setEnabled(t){this.enabled=t}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(t){let i=this.screen;i!==null?i.material=t:(i=new Ht(Pe.fullscreenGeometry,t),i.frustumCulled=!1,this.scene===null&&(this.scene=new qe),this.scene.add(i),this.screen=i)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(t){this.fullscreenMaterial=t}getDepthTexture(){return null}setDepthTexture(t,i=Z){}render(t,i,s,n,a){throw new Error("Render method not implemented!")}setSize(t,i){}initialize(t,i,s){}dispose(){for(const t of Object.keys(this)){const i=this[t];(i instanceof N||i instanceof ot||i instanceof lt||i instanceof Pe)&&this[t].dispose()}this.fullscreenMaterial!==null&&this.fullscreenMaterial.dispose()}},ts=class extends U{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,i,s,n){const a=e.state.buffers.stencil;a.setLocked(!1),a.setTest(!1)}},ss=`#ifdef COLOR_WRITE
#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#endif
#ifdef DEPTH_WRITE
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
#ifdef USE_WEIGHTS
uniform vec4 channelWeights;
#endif
uniform float opacity;varying vec2 vUv;void main(){
#ifdef COLOR_WRITE
vec4 texel=texture2D(inputBuffer,vUv);
#ifdef USE_WEIGHTS
texel*=channelWeights;
#endif
gl_FragColor=opacity*texel;
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
#else
gl_FragColor=vec4(0.0);
#endif
#ifdef DEPTH_WRITE
gl_FragDepth=readDepth(vUv);
#endif
}`,ae="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",ut=class extends O{constructor(){super({name:"CopyMaterial",defines:{COLOR_SPACE_CONVERSION:"1",DEPTH_PACKING:"0",COLOR_WRITE:"1"},uniforms:{inputBuffer:new h(null),depthBuffer:new h(null),channelWeights:new h(null),opacity:new h(1)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:ss,vertexShader:ae}),this.depthFunc=Vt}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(e){const t=e!==null;this.colorWrite!==t&&(t?this.defines.COLOR_WRITE=!0:delete this.defines.COLOR_WRITE,this.colorWrite=t,this.needsUpdate=!0),this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){const t=e!==null;this.depthWrite!==t&&(t?this.defines.DEPTH_WRITE=!0:delete this.defines.DEPTH_WRITE,this.depthTest=t,this.depthWrite=t,this.needsUpdate=!0),this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}get colorSpaceConversion(){return this.defines.COLOR_SPACE_CONVERSION!==void 0}set colorSpaceConversion(e){this.colorSpaceConversion!==e&&(e?this.defines.COLOR_SPACE_CONVERSION=!0:delete this.defines.COLOR_SPACE_CONVERSION,this.needsUpdate=!0)}get channelWeights(){return this.uniforms.channelWeights.value}set channelWeights(e){e!==null?(this.defines.USE_WEIGHTS="1",this.uniforms.channelWeights.value=e):delete this.defines.USE_WEIGHTS,this.needsUpdate=!0}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},is=class extends U{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new ut,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new N(1,1,{minFilter:me,magFilter:me,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,i,s,n){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,i){i!==void 0&&(this.renderTarget.texture.type=i,i!==z?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":e!==null&&e.outputColorSpace===w&&(this.renderTarget.texture.colorSpace=w))}},tt=new rt,ht=class extends U{constructor(e=!0,t=!0,i=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=i,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,i){this.color=e,this.depth=t,this.stencil=i}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,i,s,n){const a=this.overrideClearColor,o=this.overrideClearAlpha,l=e.getClearAlpha(),u=a!==null,v=o>=0;u?(e.getClearColor(tt),e.setClearColor(a,v?o:l)):v&&e.setClearAlpha(o),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),u?e.setClearColor(tt,l):v&&e.setClearAlpha(l)}},rs=class extends U{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new ht(!1,!1,!0),this.inverse=!1}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,i,s,n){const a=e.getContext(),o=e.state.buffers,l=this.scene,u=this.camera,v=this.clearPass,f=this.inverted?0:1,m=1-f;o.color.setMask(!1),o.depth.setMask(!1),o.color.setLocked(!0),o.depth.setLocked(!0),o.stencil.setTest(!0),o.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),o.stencil.setFunc(a.ALWAYS,f,4294967295),o.stencil.setClear(m),o.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?v.render(e,null):(v.render(e,t),v.render(e,i))),this.renderToScreen?(e.setRenderTarget(null),e.render(l,u)):(e.setRenderTarget(t),e.render(l,u),e.setRenderTarget(i),e.render(l,u)),o.color.setLocked(!1),o.depth.setLocked(!1),o.stencil.setLocked(!1),o.stencil.setFunc(a.EQUAL,1,4294967295),o.stencil.setOp(a.KEEP,a.KEEP,a.KEEP),o.stencil.setLocked(!0)}},Ti=class{constructor(e=null,{depthBuffer:t=!0,stencilBuffer:i=!1,multisampling:s=0,frameBufferType:n}={}){this.renderer=null,this.inputBuffer=this.createBuffer(t,i,n,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new is,this.depthTexture=null,this.passes=[],this.timer=new Jt,this.autoRenderToScreen=!0,this.setRenderer(e)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(e){const t=this.inputBuffer,i=this.multisampling;i>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e,this.inputBuffer.dispose(),this.outputBuffer.dispose()):i!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(t.depthBuffer,t.stencilBuffer,t.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(e){if(this.renderer=e,e!==null){const t=e.getSize(new x),i=e.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===z&&e.outputColorSpace===w&&(this.inputBuffer.texture.colorSpace=w,this.outputBuffer.texture.colorSpace=w,this.inputBuffer.dispose(),this.outputBuffer.dispose()),e.autoClear=!1,this.setSize(t.width,t.height);for(const n of this.passes)n.initialize(e,i,s)}}replaceRenderer(e,t=!0){const i=this.renderer,s=i.domElement.parentNode;return this.setRenderer(e),t&&s!==null&&(s.removeChild(i.domElement),s.appendChild(e.domElement)),i}createDepthTexture(){const e=this.depthTexture=new Nt;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=Ot,e.type=Ft):e.type=zt,e}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const e of this.passes)e.setDepthTexture(null)}}createBuffer(e,t,i,s){const n=this.renderer,a=n===null?new x:n.getDrawingBufferSize(new x),o={minFilter:me,magFilter:me,stencilBuffer:t,depthBuffer:e,type:i},l=new N(a.width,a.height,o);return s>0&&(l.samples=s),i===z&&n!==null&&n.outputColorSpace===w&&(l.texture.colorSpace=w),l.texture.name="EffectComposer.Buffer",l.texture.generateMipmaps=!1,l}setMainScene(e){for(const t of this.passes)t.mainScene=e}setMainCamera(e){for(const t of this.passes)t.mainCamera=e}addPass(e,t){const i=this.passes,s=this.renderer,n=s.getDrawingBufferSize(new x),a=s.getContext().getContextAttributes().alpha,o=this.inputBuffer.texture.type;if(e.setRenderer(s),e.setSize(n.width,n.height),e.initialize(s,a,o),this.autoRenderToScreen&&(i.length>0&&(i[i.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),t!==void 0?i.splice(t,0,e):i.push(e),this.autoRenderToScreen&&(i[i.length-1].renderToScreen=!0),e.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const l=this.createDepthTexture();for(e of i)e.setDepthTexture(l)}else e.setDepthTexture(this.depthTexture)}removePass(e){const t=this.passes,i=t.indexOf(e);if(i!==-1&&t.splice(i,1).length>0){if(this.depthTexture!==null){const a=(l,u)=>l||u.needsDepthTexture;t.reduce(a,!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&i===t.length&&(e.renderToScreen=!1,t.length>0&&(t[t.length-1].renderToScreen=!0))}}removeAllPasses(){const e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}render(e){const t=this.renderer,i=this.copyPass;let s=this.inputBuffer,n=this.outputBuffer,a=!1,o,l,u;e===void 0&&(this.timer.update(),e=this.timer.getDelta());for(const v of this.passes)v.enabled&&(v.render(t,s,n,e,a),v.needsSwap&&(a&&(i.renderToScreen=v.renderToScreen,o=t.getContext(),l=t.state.buffers.stencil,l.setFunc(o.NOTEQUAL,1,4294967295),i.render(t,s,n,e,a),l.setFunc(o.EQUAL,1,4294967295)),u=s,s=n,n=u),v instanceof rs?a=!0:v instanceof ts&&(a=!1))}setSize(e,t,i){const s=this.renderer,n=s.getSize(new x);(e===void 0||t===void 0)&&(e=n.width,t=n.height),(n.width!==e||n.height!==t)&&s.setSize(e,t,i);const a=s.getDrawingBufferSize(new x);this.inputBuffer.setSize(a.width,a.height),this.outputBuffer.setSize(a.width,a.height);for(const o of this.passes)o.setSize(a.width,a.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const e of this.passes)e.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose(),U.fullscreenGeometry.dispose()}},K={NONE:0,DEPTH:1,CONVOLUTION:2},T={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},ns=class{constructor(){this.shaderParts=new Map([[T.FRAGMENT_HEAD,null],[T.FRAGMENT_MAIN_UV,null],[T.FRAGMENT_MAIN_IMAGE,null],[T.VERTEX_HEAD,null],[T.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=K.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=nt}},De=!1,st=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let i;if(t.material.flatShading)switch(t.material.side){case de:i=this.materialsFlatShadedDoubleSide;break;case he:i=this.materialsFlatShadedBackSide;break;default:i=this.materialsFlatShaded;break}else switch(t.material.side){case de:i=this.materialsDoubleSide;break;case he:i=this.materialsBackSide;break;default:i=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=i[2]:t.isInstancedMesh?t.material=i[1]:t.material=i[0],++this.meshCount}}}cloneMaterial(e){if(!(e instanceof O))return e.clone();const t=e.uniforms,i=new Map;for(const n in t){const a=t[n].value;a.isRenderTargetTexture&&(t[n].value=null,i.set(n,a))}const s=e.clone();for(const n of i)t[n[0]].value=n[1],s.uniforms[n[0]].value=n[1];return s}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){const t=this.materials=[this.cloneMaterial(e),this.cloneMaterial(e),this.cloneMaterial(e)];for(const i of t)i.uniforms=Object.assign({},e.uniforms),i.side=Gt;t[2].skinning=!0,this.materialsBackSide=t.map(i=>{const s=this.cloneMaterial(i);return s.uniforms=Object.assign({},e.uniforms),s.side=he,s}),this.materialsDoubleSide=t.map(i=>{const s=this.cloneMaterial(i);return s.uniforms=Object.assign({},e.uniforms),s.side=de,s}),this.materialsFlatShaded=t.map(i=>{const s=this.cloneMaterial(i);return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s}),this.materialsFlatShadedBackSide=t.map(i=>{const s=this.cloneMaterial(i);return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s.side=he,s}),this.materialsFlatShadedDoubleSide=t.map(i=>{const s=this.cloneMaterial(i);return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s.side=de,s})}}render(e,t,i){const s=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,De){const n=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,i);for(const a of n)a[0].material=a[1];this.meshCount!==n.size&&n.clear()}else{const n=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,i),t.overrideMaterial=n}e.shadowMap.enabled=s}disposeMaterials(){if(this.material!==null){const e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return De}static set workaroundEnabled(e){De=e}},W=-1,P=class extends Ce{constructor(e,t=W,i=W,s=1){super(),this.resizable=e,this.baseSize=new x(1,1),this.preferredSize=new x(t,i),this.target=this.preferredSize,this.s=s,this.effectiveSize=new x,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,t=this.preferredSize,i=this.effectiveSize,s=this.scale;t.width!==W?i.width=t.width:t.height!==W?i.width=Math.round(t.height*(e.width/Math.max(e.height,1))):i.width=Math.round(e.width*s),t.height!==W?i.height=t.height:t.width!==W?i.height=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):i.height=Math.round(e.height*s)}get width(){return this.effectiveSize.width}set width(e){this.preferredWidth=e}get height(){return this.effectiveSize.height}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferredSize.setScalar(W),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(e){this.baseWidth=e}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.baseSize.width!==e||this.baseSize.height!==t)&&(this.baseSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferredSize.width!==e||this.preferredSize.height!==t)&&(this.preferredSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(e){this.s=e.scale,this.baseSize.set(e.baseWidth,e.baseHeight),this.preferredSize.set(e.preferredWidth,e.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return W}},g={ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},as="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb+src.rgb;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",os="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){return mix(dst,src,src.a*opacity);}",ls="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=(dst.rgb+src.rgb)*0.5;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",cs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(b.xy,a.z));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",us="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=dst.rgb,b=src.rgb;vec3 c=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/max(b,1e-9))),vec3(1.0),step(1.0,a));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",hs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=dst.rgb,b=src.rgb;vec3 c=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",ds="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=min(dst.rgb,src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",fs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=abs(dst.rgb-src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",ps="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb/max(src.rgb,1e-9);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",vs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb+src.rgb-2.0*dst.rgb*src.rgb;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",ms="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=min(dst.rgb,1.0);vec3 b=min(src.rgb,1.0);vec3 c=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",gs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=step(1.0,dst.rgb+src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Ss="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(b.x,a.yz));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Ts="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(1.0-src.rgb,0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Es="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=src.rgb*max(1.0-dst.rgb,0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",bs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(dst.rgb,src.rgb);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",xs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=clamp(src.rgb+dst.rgb-1.0,0.0,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Ms="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=min(dst.rgb+src.rgb,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",_s="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=clamp(2.0*src.rgb+dst.rgb-1.0,0.0,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Rs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(a.xy,b.z));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",ws="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb*src.rgb;return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Ds="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(1.0-abs(1.0-dst.rgb-src.rgb),0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Ps="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){return mix(dst,src,opacity);}",Cs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=2.0*src.rgb*dst.rgb;vec3 b=1.0-2.0*(1.0-src.rgb)*(1.0-dst.rgb);vec3 c=mix(a,b,step(0.5,dst.rgb));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Bs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 src2=2.0*src.rgb;vec3 c=mix(mix(src2,dst.rgb,step(0.5*dst.rgb,src.rgb)),max(src2-1.0,vec3(0.0)),step(dst.rgb,src2-1.0));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Us="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=min(dst.rgb*dst.rgb/max(1.0-src.rgb,1e-9),1.0);vec3 c=mix(a,src.rgb,step(1.0,src.rgb));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",ys="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 a=RGBToHSL(dst.rgb);vec3 b=RGBToHSL(src.rgb);vec3 c=HSLToRGB(vec3(a.x,b.y,a.z));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",As="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=dst.rgb+src.rgb-min(dst.rgb*src.rgb,1.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Is="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 src2=2.0*src.rgb;vec3 d=dst.rgb+(src2-1.0);vec3 w=step(0.5,src.rgb);vec3 a=dst.rgb-(1.0-src2)*dst.rgb*(1.0-dst.rgb);vec3 b=mix(d*(sqrt(dst.rgb)-dst.rgb),d*dst.rgb*((16.0*dst.rgb-12.0)*dst.rgb+3.0),w*(1.0-step(0.25,dst.rgb)));vec3 c=mix(a,b,w);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Ns="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){return src;}",Os="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=max(dst.rgb-src.rgb,0.0);return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",Fs="vec4 blend(const in vec4 dst,const in vec4 src,const in float opacity){vec3 c=mix(max(1.0-min((1.0-dst.rgb)/(2.0*src.rgb),1.0),0.0),min(dst.rgb/(2.0*(1.0-src.rgb)),1.0),step(0.5,src.rgb));return mix(dst,vec4(c,max(dst.a,src.a)),opacity);}",zs=new Map([[g.ADD,as],[g.ALPHA,os],[g.AVERAGE,ls],[g.COLOR,cs],[g.COLOR_BURN,us],[g.COLOR_DODGE,hs],[g.DARKEN,ds],[g.DIFFERENCE,fs],[g.DIVIDE,ps],[g.DST,null],[g.EXCLUSION,vs],[g.HARD_LIGHT,ms],[g.HARD_MIX,gs],[g.HUE,Ss],[g.INVERT,Ts],[g.INVERT_RGB,Es],[g.LIGHTEN,bs],[g.LINEAR_BURN,xs],[g.LINEAR_DODGE,Ms],[g.LINEAR_LIGHT,_s],[g.LUMINOSITY,Rs],[g.MULTIPLY,ws],[g.NEGATION,Ds],[g.NORMAL,Ps],[g.OVERLAY,Cs],[g.PIN_LIGHT,Bs],[g.REFLECT,Us],[g.SATURATION,ys],[g.SCREEN,As],[g.SOFT_LIGHT,Is],[g.SRC,Ns],[g.SUBTRACT,Os],[g.VIVID_LIGHT,Fs]]),ks=class extends Ce{constructor(e,t=1){super(),this._blendFunction=e,this.opacity=new h(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return zs.get(this.blendFunction)}},dt=class extends Ce{constructor(e,t,{attributes:i=K.NONE,blendFunction:s=g.NORMAL,defines:n=new Map,uniforms:a=new Map,extensions:o=null,vertexShader:l=null}={}){super(),this.name=e,this.renderer=null,this.attributes=i,this.fragmentShader=t,this.vertexShader=l,this.defines=n,this.uniforms=a,this.extensions=o,this.blendMode=new ks(s),this.blendMode.addEventListener("change",u=>this.setChanged()),this._inputColorSpace=nt,this._outputColorSpace=at}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(e){this._inputColorSpace=e,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e,this.setChanged()}set mainScene(e){}set mainCamera(e){}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=Z){}update(e,t,i){}setSize(e,t){}initialize(e,t,i){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof N||t instanceof ot||t instanceof lt||t instanceof U)&&this[e].dispose()}}},Se={MEDIUM:2,LARGE:3},Ls=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,Hs="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",Gs=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],Vs=class extends O{constructor(e=new Qe){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new h(null),texelSize:new h(new Qe),scale:new h(1),kernel:new h(0)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Ls,vertexShader:Hs}),this.setTexelSize(e.x,e.y),this.kernelSize=Se.MEDIUM}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.inputBuffer=e}get kernelSequence(){return Gs[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(){return this.uniforms.scale.value}setScale(e){this.uniforms.scale.value=e}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(e){this.uniforms.kernel.value=e}setKernel(e){this.kernel=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t,e*.5,t*.5)}setSize(e,t){const i=1/e,s=1/t;this.uniforms.texelSize.value.set(i,s,i*.5,s*.5)}},ft=class extends U{constructor({kernelSize:e=Se.MEDIUM,resolutionScale:t=.5,width:i=P.AUTO_SIZE,height:s=P.AUTO_SIZE,resolutionX:n=i,resolutionY:a=s}={}){super("KawaseBlurPass"),this.renderTargetA=new N(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const o=this.resolution=new P(this,n,a,t);o.addEventListener("change",l=>this.setSize(o.baseWidth,o.baseHeight)),this._blurMaterial=new Vs,this._blurMaterial.kernelSize=e,this.copyMaterial=new ut}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(e){this._blurMaterial=e}get dithering(){return this.copyMaterial.dithering}set dithering(e){this.copyMaterial.dithering=e}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(e){this.blurMaterial.kernelSize=e}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get scale(){return this.blurMaterial.scale}set scale(e){this.blurMaterial.scale=e}getScale(){return this.blurMaterial.scale}setScale(e){this.blurMaterial.scale=e}getKernelSize(){return this.kernelSize}setKernelSize(e){this.kernelSize=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,i,s,n){const a=this.scene,o=this.camera,l=this.renderTargetA,u=this.renderTargetB,v=this.blurMaterial,f=v.kernelSequence;let m=t;this.fullscreenMaterial=v;for(let S=0,M=f.length;S<M;++S){const C=(S&1)===0?l:u;v.kernel=f[S],v.inputBuffer=m.texture,e.setRenderTarget(C),e.render(a,o),m=C}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=m.texture,e.setRenderTarget(this.renderToScreen?null:i),e.render(a,o)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t);const s=i.width,n=i.height;this.renderTargetA.setSize(s,n),this.renderTargetB.setSize(s,n),this.blurMaterial.setSize(e,t)}initialize(e,t,i){i!==void 0&&(this.renderTargetA.texture.type=i,this.renderTargetB.texture.type=i,i!==z?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):e!==null&&e.outputColorSpace===w&&(this.renderTargetA.texture.colorSpace=w,this.renderTargetB.texture.colorSpace=w))}static get AUTO_SIZE(){return P.AUTO_SIZE}},js=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`,Ws=class extends O{constructor(e=!1,t=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:ct.replace(/\D+/g,"")},uniforms:{inputBuffer:new h(null),threshold:new h(0),smoothing:new h(1),range:new h(null)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:js,vertexShader:ae}),this.colorOutput=e,this.luminanceRange=t}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get threshold(){return this.uniforms.threshold.value}set threshold(e){this.smoothing>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=e}getThreshold(){return this.threshold}setThreshold(e){this.threshold=e}get smoothing(){return this.uniforms.smoothing.value}set smoothing(e){this.threshold>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=e}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(e){this.smoothing=e}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(e){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(e){e?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(e){return this.colorOutput}setColorOutputEnabled(e){this.colorOutput=e}get useRange(){return this.luminanceRange!==null}set useRange(e){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(e){e!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=e,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(e){this.luminanceRange=e}},Ks=class extends U{constructor({renderTarget:e,luminanceRange:t,colorOutput:i,resolutionScale:s=1,width:n=P.AUTO_SIZE,height:a=P.AUTO_SIZE,resolutionX:o=n,resolutionY:l=a}={}){super("LuminancePass"),this.fullscreenMaterial=new Ws(i,t),this.needsSwap=!1,this.renderTarget=e,this.renderTarget===void 0&&(this.renderTarget=new N(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const u=this.resolution=new P(this,o,l,s);u.addEventListener("change",v=>this.setSize(u.baseWidth,u.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(e,t,i,s,n){const a=this.fullscreenMaterial;a.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height)}initialize(e,t,i){i!==void 0&&i!==z&&(this.renderTarget.texture.type=i,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},Zs=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`,Ys="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",Xs=class extends O{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new h(null),texelSize:new h(new x)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Zs,vertexShader:Ys})}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},qs=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`,$s="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",Qs=class extends O{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new h(null),supportBuffer:new h(null),texelSize:new h(new x),radius:new h(.85)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:qs,vertexShader:$s})}set inputBuffer(e){this.uniforms.inputBuffer.value=e}set supportBuffer(e){this.uniforms.supportBuffer.value=e}get radius(){return this.uniforms.radius.value}set radius(e){this.uniforms.radius.value=e}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},Js=class extends U{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new N(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new Xs,this.upsamplingMaterial=new Qs,this.resolution=new x}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(e){if(this.levels!==e){const t=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let i=0;i<e;++i){const s=t.clone();s.texture.name="Downsampling.Mipmap"+i,this.downsamplingMipmaps.push(s)}this.upsamplingMipmaps.push(t);for(let i=1,s=e-1;i<s;++i){const n=t.clone();n.texture.name="Upsampling.Mipmap"+i,this.upsamplingMipmaps.push(n)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(e){this.upsamplingMaterial.radius=e}render(e,t,i,s,n){const{scene:a,camera:o}=this,{downsamplingMaterial:l,upsamplingMaterial:u}=this,{downsamplingMipmaps:v,upsamplingMipmaps:f}=this;let m=t;this.fullscreenMaterial=l;for(let S=0,M=v.length;S<M;++S){const C=v[S];l.setSize(m.width,m.height),l.inputBuffer=m.texture,e.setRenderTarget(C),e.render(a,o),m=C}this.fullscreenMaterial=u;for(let S=f.length-1;S>=0;--S){const M=f[S];u.setSize(m.width,m.height),u.inputBuffer=m.texture,u.supportBuffer=v[S].texture,e.setRenderTarget(M),e.render(a,o),m=M}}setSize(e,t){const i=this.resolution;i.set(e,t);let s=i.width,n=i.height;for(let a=0,o=this.downsamplingMipmaps.length;a<o;++a)s=Math.round(s*.5),n=Math.round(n*.5),this.downsamplingMipmaps[a].setSize(s,n),a<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[a].setSize(s,n)}initialize(e,t,i){if(i!==void 0){const s=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const n of s)n.texture.type=i;if(i!==z)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(e!==null&&e.outputColorSpace===w)for(const n of s)n.texture.colorSpace=w}}dispose(){super.dispose();for(const e of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))e.dispose()}},ei=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`,Ei=class extends dt{constructor({blendFunction:e=g.SCREEN,luminanceThreshold:t=1,luminanceSmoothing:i=.03,mipmapBlur:s=!0,intensity:n=1,radius:a=.85,levels:o=8,kernelSize:l=Se.LARGE,resolutionScale:u=.5,width:v=P.AUTO_SIZE,height:f=P.AUTO_SIZE,resolutionX:m=v,resolutionY:S=f}={}){super("BloomEffect",ei,{blendFunction:e,uniforms:new Map([["map",new h(null)],["intensity",new h(n)]])}),this.renderTarget=new N(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new ft({kernelSize:l}),this.luminancePass=new Ks({colorOutput:!0}),this.luminanceMaterial.threshold=t,this.luminanceMaterial.smoothing=i,this.mipmapBlurPass=new Js,this.mipmapBlurPass.enabled=s,this.mipmapBlurPass.radius=a,this.mipmapBlurPass.levels=o,this.uniforms.get("map").value=s?this.mipmapBlurPass.texture:this.renderTarget.texture;const M=this.resolution=new P(this,m,S,u);M.addEventListener("change",C=>this.setSize(M.baseWidth,M.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get dithering(){return this.blurPass.dithering}set dithering(e){this.blurPass.dithering=e}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(e){this.blurPass.kernelSize=e}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(e){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(e){this.uniforms.get("intensity").value=e}getIntensity(){return this.intensity}setIntensity(e){this.intensity=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}update(e,t,i){const s=this.renderTarget,n=this.luminancePass;n.enabled?(n.render(e,t),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(e,n.renderTarget):this.blurPass.render(e,n.renderTarget,s)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(e,t):this.blurPass.render(e,t,s)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height),this.blurPass.resolution.copy(i),this.luminancePass.setSize(e,t),this.mipmapBlurPass.setSize(e,t)}initialize(e,t,i){this.blurPass.initialize(e,t,i),this.luminancePass.initialize(e,t,i),this.mipmapBlurPass.initialize(e,t,i),i!==void 0&&(this.renderTarget.texture.type=i,e!==null&&e.outputColorSpace===w&&(this.renderTarget.texture.colorSpace=w))}},pt={RED:0,GREEN:1},vt={DISCARD:0,MULTIPLY_RGB_SET_ALPHA:2,MULTIPLY_RGB:3},ti=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;
#else
float coc=texture2D(cocBuffer,vUv).g*scale;
#endif
if(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);
#else
vec2 step=texelSize*coc;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,pe=class extends O{constructor(e=!1,t=!1){super({name:"BokehMaterial",defines:{PASS:e?"2":"1"},uniforms:{inputBuffer:new h(null),cocBuffer:new h(null),texelSize:new h(new x),kernel64:new h(null),kernel16:new h(null),scale:new h(1)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:ti,vertexShader:ae}),t&&(this.defines.FOREGROUND="1"),this.generateKernel()}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}set cocBuffer(e){this.uniforms.cocBuffer.value=e}setCoCBuffer(e){this.uniforms.cocBuffer.value=e}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(e){return this.scale}setScale(e){this.scale=e}generateKernel(){const e=2.39996323,t=new Float64Array(128),i=new Float64Array(32);let s=0,n=0;for(let a=0,o=Math.sqrt(80);a<80;++a){const l=a*e,u=Math.sqrt(a)/o,v=u*Math.cos(l),f=u*Math.sin(l);a%5===0?(i[n++]=v,i[n++]=f):(t[s++]=v,t[s++]=f)}this.uniforms.kernel64.value=t,this.uniforms.kernel16.value=i}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},si=`#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform float cameraNear;uniform float cameraFar;uniform float focusDistance;uniform float focusRange;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#if defined(USE_LOGARITHMIC_DEPTH_BUFFER) || defined(LOG_DEPTH)
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#elif defined(USE_REVERSED_DEPTH_BUFFER)
depth=1.0-depth;
#endif
return depth;}
#ifdef PERSPECTIVE_CAMERA
#define getViewZ(depth) perspectiveDepthToViewZ(depth, cameraNear, cameraFar)
#else
#define getViewZ(depth) orthographicDepthToViewZ(depth, cameraNear, cameraFar)
#endif
vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(projectionMatrixInverse*clipPosition).xyz;}vec3 getViewPosition(const in vec2 screenPosition,const in float depth){return getViewPosition(screenPosition,depth,getViewZ(depth));}
#define getDistance(viewPosition) length(viewPosition)
void main(){float depth=readDepth(vUv);vec3 viewPosition=getViewPosition(vUv,depth);float distance=getDistance(viewPosition);float signedDistance=distance-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`,ii=class extends O{constructor(e=null){super({name:"CircleOfConfusionMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new h(null),projectionMatrix:new h(null),projectionMatrixInverse:new h(null),cameraNear:new h(.3),cameraFar:new h(1e3),focusDistance:new h(0),focusRange:new h(0)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:si,vertexShader:ae}),this.uniforms.focalLength=this.uniforms.focusRange,e!==null&&this.copyCameraSettings(e)}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Z){this.depthBuffer=e,this.depthPacking=t}get focusDistance(){return this.uniforms.focusDistance.value}set focusDistance(e){this.uniforms.focusDistance.value=e}get worldFocusDistance(){return this.focusDistance}set worldFocusDistance(e){this.focusDistance=e}getFocusDistance(e){this.uniforms.focusDistance.value=e}setFocusDistance(e){this.uniforms.focusDistance.value=e}get focalLength(){return this.focusRange}set focalLength(e){this.focusRange=e}get focusRange(){return this.uniforms.focusRange.value}set focusRange(e){this.uniforms.focusRange.value=e}get worldFocusRange(){return this.focusRange}set worldFocusRange(e){this.focusRange=e}getFocalLength(e){return this.focusRange}setFocalLength(e){this.focusRange=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){this.uniforms.projectionMatrix.value=e.projectionMatrix,this.uniforms.projectionMatrixInverse.value=e.projectionMatrixInverse,this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far;const t=this.defines.PERSPECTIVE_CAMERA!==void 0;e instanceof ne?t||(this.defines.PERSPECTIVE_CAMERA=!0,this.needsUpdate=!0):t&&(delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}},ri=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=(mask>0.0)?0.0:1.0;
#else
mask=(mask>0.0)?1.0:0.0;
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 3
vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);
#elif MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,ni=class extends O{constructor(e=null){super({name:"MaskMaterial",uniforms:{maskTexture:new h(e),inputBuffer:new h(null),strength:new h(1)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:ri,vertexShader:ae}),this.colorChannel=pt.RED,this.maskFunction=vt.DISCARD}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}set maskTexture(e){this.uniforms.maskTexture.value=e,delete this.defines.MASK_PRECISION_HIGH,e.type!==z&&(this.defines.MASK_PRECISION_HIGH="1"),this.needsUpdate=!0}setMaskTexture(e){this.maskTexture=e}set colorChannel(e){this.defines.COLOR_CHANNEL=e.toFixed(0),this.needsUpdate=!0}setColorChannel(e){this.colorChannel=e}set maskFunction(e){this.defines.MASK_FUNCTION=e.toFixed(0),this.needsUpdate=!0}setMaskFunction(e){this.maskFunction=e}get inverted(){return this.defines.INVERTED!==void 0}set inverted(e){this.inverted&&!e?delete this.defines.INVERTED:e&&(this.defines.INVERTED="1"),this.needsUpdate=!0}isInverted(){return this.inverted}setInverted(e){this.inverted=e}get strength(){return this.uniforms.strength.value}set strength(e){this.uniforms.strength.value=e}getStrength(){return this.strength}setStrength(e){this.strength=e}},J=class extends U{constructor(e,t="inputBuffer"){super("ShaderPass"),this.fullscreenMaterial=e,this.input=t}setInput(e){this.input=e}render(e,t,i,s,n){const a=this.fullscreenMaterial.uniforms;t!==null&&a!==void 0&&a[this.input]!==void 0&&(a[this.input].value=t.texture),e.setRenderTarget(this.renderToScreen?null:i),e.render(this.scene,this.camera)}initialize(e,t,i){i!==void 0&&i!==z&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},ai=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
#if MASK_FUNCTION != 1 && MASK_FUNCTION != 2
uniform lowp sampler2D farCoCBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);
#if MASK_FUNCTION == 1 || MASK_FUNCTION == 2
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);
#else
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);colorFar.a*=cocNearFar.y;
#endif
vec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}`,oi=new A,bi=class extends dt{constructor(e,{blendFunction:t,worldFocusDistance:i,worldFocusRange:s,focalLength:n,focusDistance:a=i||3,focusRange:o=s||n||2,bokehScale:l=1,resolutionScale:u=.5,width:v,height:f,resolutionX:m=v||P.AUTO_SIZE,resolutionY:S=f||P.AUTO_SIZE}={}){super("DepthOfFieldEffect",ai,{blendFunction:t,attributes:K.DEPTH,uniforms:new Map([["nearColorBuffer",new h(null)],["farColorBuffer",new h(null)],["nearCoCBuffer",new h(null)],["farCoCBuffer",new h(null)],["scale",new h(1)]])}),this.camera=e,this.renderTarget=new N(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="DoF.Intermediate",this.renderTargetMasked=this.renderTarget.clone(),this.renderTargetMasked.texture.name="DoF.Masked.Far",this.renderTargetNear=this.renderTarget.clone(),this.renderTargetNear.texture.name="DoF.Bokeh.Near",this.uniforms.get("nearColorBuffer").value=this.renderTargetNear.texture,this.renderTargetFar=this.renderTarget.clone(),this.renderTargetFar.texture.name="DoF.Bokeh.Far",this.uniforms.get("farColorBuffer").value=this.renderTargetFar.texture,this.renderTargetCoC=this.renderTarget.clone(),this.renderTargetCoC.texture.name="DoF.CoC",this.uniforms.get("farCoCBuffer").value=this.renderTargetCoC.texture,this.renderTargetCoCBlurred=this.renderTargetCoC.clone(),this.renderTargetCoCBlurred.texture.name="DoF.CoC.Blurred",this.uniforms.get("nearCoCBuffer").value=this.renderTargetCoCBlurred.texture,this.cocPass=new J(new ii(e));const M=this.cocMaterial;M.focusDistance=a,M.focusRange=o,this.blurPass=new ft({resolutionScale:u,resolutionX:m,resolutionY:S,kernelSize:Se.MEDIUM}),this.maskPass=new J(new ni(this.renderTargetCoC.texture));const C=this.maskPass.fullscreenMaterial;C.colorChannel=pt.GREEN,this.maskFunction=vt.MULTIPLY_RGB,this.bokehNearBasePass=new J(new pe(!1,!0)),this.bokehNearBasePass.fullscreenMaterial.cocBuffer=this.renderTargetCoCBlurred.texture,this.bokehNearFillPass=new J(new pe(!0,!0)),this.bokehNearFillPass.fullscreenMaterial.cocBuffer=this.renderTargetCoCBlurred.texture,this.bokehFarBasePass=new J(new pe(!1,!1)),this.bokehFarBasePass.fullscreenMaterial.cocBuffer=this.renderTargetCoC.texture,this.bokehFarFillPass=new J(new pe(!0,!1)),this.bokehFarFillPass.fullscreenMaterial.cocBuffer=this.renderTargetCoC.texture,this.target=null;const R=this.resolution=new P(this,m,S,u);R.addEventListener("change",I=>this.setSize(R.baseWidth,R.baseHeight)),this.bokehScale=l}set mainCamera(e){this.camera=e,this.cocMaterial.copyCameraSettings(e)}get cocTexture(){return this.renderTargetCoC.texture}get maskFunction(){return this.maskPass.fullscreenMaterial.maskFunction}set maskFunction(e){this.maskFunction!==e&&(this.defines.set("MASK_FUNCTION",e.toFixed(0)),this.maskPass.fullscreenMaterial.maskFunction=e,this.setChanged())}get cocMaterial(){return this.cocPass.fullscreenMaterial}get circleOfConfusionMaterial(){return this.cocMaterial}getCircleOfConfusionMaterial(){return this.cocMaterial}getBlurPass(){return this.blurPass}getResolution(){return this.resolution}get bokehScale(){return this.uniforms.get("scale").value}set bokehScale(e){this.bokehNearBasePass.fullscreenMaterial.scale=e,this.bokehNearFillPass.fullscreenMaterial.scale=e,this.bokehFarBasePass.fullscreenMaterial.scale=e,this.bokehFarFillPass.fullscreenMaterial.scale=e,this.maskPass.fullscreenMaterial.strength=e,this.uniforms.get("scale").value=e}getBokehScale(){return this.bokehScale}setBokehScale(e){this.bokehScale=e}getTarget(){return this.target}setTarget(e){this.target=e}calculateFocusDistance(e){return this.camera.getWorldPosition(oi).distanceTo(e)}setDepthTexture(e,t=Z){this.cocMaterial.depthBuffer=e,this.cocMaterial.depthPacking=t}update(e,t,i){const s=this.renderTarget,n=this.renderTargetCoC,a=this.renderTargetCoCBlurred,o=this.renderTargetMasked;if(this.target!==null){const l=this.calculateFocusDistance(this.target);this.cocMaterial.focusDistance=l}this.cocPass.render(e,null,n),this.blurPass.render(e,n,a),this.maskPass.render(e,t,o),this.bokehFarBasePass.render(e,o,s),this.bokehFarFillPass.render(e,s,this.renderTargetFar),this.bokehNearBasePass.render(e,t,s),this.bokehNearFillPass.render(e,s,this.renderTargetNear)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t);const s=i.width,n=i.height;this.cocPass.setSize(e,t),this.blurPass.setSize(e,t),this.maskPass.setSize(e,t),this.renderTargetFar.setSize(e,t),this.renderTargetCoC.setSize(e,t),this.renderTargetMasked.setSize(e,t),this.renderTarget.setSize(s,n),this.renderTargetNear.setSize(s,n),this.renderTargetCoCBlurred.setSize(s,n),this.bokehNearBasePass.fullscreenMaterial.setSize(e,t),this.bokehNearFillPass.fullscreenMaterial.setSize(e,t),this.bokehFarBasePass.fullscreenMaterial.setSize(e,t),this.bokehFarFillPass.fullscreenMaterial.setSize(e,t)}initialize(e,t,i){this.cocPass.initialize(e,t,i),this.maskPass.initialize(e,t,i),this.bokehNearBasePass.initialize(e,t,i),this.bokehNearFillPass.initialize(e,t,i),this.bokehFarBasePass.initialize(e,t,i),this.bokehFarFillPass.initialize(e,t,i),this.blurPass.initialize(e,t,z),e.capabilities.logarithmicDepthBuffer&&(this.cocPass.fullscreenMaterial.defines.LOG_DEPTH="1"),i!==void 0&&(this.renderTarget.texture.type=i,this.renderTargetNear.texture.type=i,this.renderTargetFar.texture.type=i,this.renderTargetMasked.texture.type=i,e!==null&&e.outputColorSpace===w&&(this.renderTarget.texture.colorSpace=w,this.renderTargetNear.texture.colorSpace=w,this.renderTargetFar.texture.colorSpace=w,this.renderTargetMasked.texture.colorSpace=w))}},li=class extends U{constructor(e,t,i=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new ht,this.overrideMaterialManager=i===null?null:new st(i),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){const e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){const t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new st(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,i,s,n){const a=this.scene,o=this.camera,l=this.selection,u=o.layers.mask,v=a.background,f=e.shadowMap.autoUpdate,m=this.renderToScreen?null:t;l!==null&&o.layers.set(l.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(a.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(m),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,a,o):e.render(a,o),o.layers.mask=u,a.background=v,e.shadowMap.autoUpdate=f}},ci=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,ui="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",hi=class extends O{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new h(null),normalBuffer:new h(null),texelSize:new h(new x)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:ci,vertexShader:ui})}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Z){this.depthBuffer=e,this.depthPacking=t}set normalBuffer(e){this.uniforms.normalBuffer.value=e,e!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(e){this.normalBuffer=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},xi=class extends U{constructor({normalBuffer:e=null,resolutionScale:t=.5,width:i=P.AUTO_SIZE,height:s=P.AUTO_SIZE,resolutionX:n=i,resolutionY:a=s}={}){super("DepthDownsamplingPass");const o=new hi;o.normalBuffer=e,this.fullscreenMaterial=o,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new N(1,1,{minFilter:ge,magFilter:ge,depthBuffer:!1,type:Lt}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const l=this.resolution=new P(this,n,a,t);l.addEventListener("change",u=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(e,t=Z){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t}render(e,t,i,s,n){e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height),this.fullscreenMaterial.setSize(e,t)}initialize(e,t,i){const s=e.getContext();if(!(s.getExtension("EXT_color_buffer_float")||s.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},di=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#if defined(USE_LOGARITHMIC_DEPTH_BUFFER) || defined(LOG_DEPTH)
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#elif defined(USE_REVERSED_DEPTH_BUFFER)
depth=1.0-depth;
#endif
return depth;}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,fi="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",pi=class extends O{constructor(e,t,i,s,n=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:ct.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new h(null),depthBuffer:new h(null),resolution:new h(new x),texelSize:new h(new x),cameraNear:new h(.3),cameraFar:new h(1e3),aspect:new h(1),time:new h(0)},blending:k,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:n}),e&&this.setShaderParts(e),t&&this.setDefines(t),i&&this.setUniforms(i),this.copyCameraSettings(s)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Z){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){return this.fragmentShader=di.replace(T.FRAGMENT_HEAD,e.get(T.FRAGMENT_HEAD)||"").replace(T.FRAGMENT_MAIN_UV,e.get(T.FRAGMENT_MAIN_UV)||"").replace(T.FRAGMENT_MAIN_IMAGE,e.get(T.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=fi.replace(T.VERTEX_HEAD,e.get(T.VERTEX_HEAD)||"").replace(T.VERTEX_MAIN_SUPPORT,e.get(T.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof ne?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const i=this.uniforms;i.resolution.value.set(e,t),i.texelSize.value.set(1/e,1/t),i.aspect.value=e/t}static get Section(){return T}};function it(e,t,i){for(const s of t){const n="$1"+e+s.charAt(0).toUpperCase()+s.slice(1),a=new RegExp("([^\\.])(\\b"+s+"\\b)","g");for(const o of i.entries())o[1]!==null&&i.set(o[0],o[1].replace(a,n))}}function vi(e,t,i){let s=t.getFragmentShader(),n=t.getVertexShader();const a=s!==void 0&&/mainImage/.test(s),o=s!==void 0&&/mainUv/.test(s);if(i.attributes|=t.getAttributes(),s===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(o&&(i.attributes&K.CONVOLUTION)!==0)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!a&&!o)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const l=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,u=i.shaderParts;let v=u.get(T.FRAGMENT_HEAD)||"",f=u.get(T.FRAGMENT_MAIN_UV)||"",m=u.get(T.FRAGMENT_MAIN_IMAGE)||"",S=u.get(T.VERTEX_HEAD)||"",M=u.get(T.VERTEX_MAIN_SUPPORT)||"";const C=new Set,R=new Set;if(o&&(f+=`	${e}MainUv(UV);
`,i.uvTransformation=!0),n!==null&&/mainSupport/.test(n)){const _=/mainSupport *\([\w\s]*?uv\s*?\)/.test(n);M+=`	${e}MainSupport(`,M+=_?`vUv);
`:`);
`;for(const D of n.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const F of D[1].split(/\s*,\s*/))i.varyings.add(F),C.add(F),R.add(F);for(const D of n.matchAll(l))R.add(D[1])}for(const _ of s.matchAll(l))R.add(_[1]);for(const _ of t.defines.keys())R.add(_.replace(/\([\w\s,]*\)/g,""));for(const _ of t.uniforms.keys())R.add(_);R.delete("while"),R.delete("for"),R.delete("if"),t.uniforms.forEach((_,D)=>i.uniforms.set(e+D.charAt(0).toUpperCase()+D.slice(1),_)),t.defines.forEach((_,D)=>i.defines.set(e+D.charAt(0).toUpperCase()+D.slice(1),_));const I=new Map([["fragment",s],["vertex",n]]);it(e,R,i.defines),it(e,R,I),s=I.get("fragment"),n=I.get("vertex");const y=t.blendMode;if(i.blendModes.set(y.blendFunction,y),a){t.inputColorSpace!==null&&t.inputColorSpace!==i.colorSpace&&(m+=t.inputColorSpace===w?`color0 = sRGBTransferOETF(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==at?i.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(i.colorSpace=t.inputColorSpace);const _=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;m+=`${e}MainImage(color0, UV, `,(i.attributes&K.DEPTH)!==0&&_.test(s)&&(m+="depth, ",i.readDepth=!0),m+=`color1);
	`;const D=e+"BlendOpacity";i.uniforms.set(D,y.opacity),m+=`color0 = blend${y.blendFunction}(color0, color1, ${D});

	`,v+=`uniform float ${D};

`}if(v+=s+`
`,n!==null&&(S+=n+`
`),u.set(T.FRAGMENT_HEAD,v),u.set(T.FRAGMENT_MAIN_UV,f),u.set(T.FRAGMENT_MAIN_IMAGE,m),u.set(T.VERTEX_HEAD,S),u.set(T.VERTEX_MAIN_SUPPORT,M),t.extensions!==null)for(const _ of t.extensions)i.extensions.add(_)}}var Mi=class extends U{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new pi(null,null,null,e),this.listener=i=>this.handleEvent(i),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort((t,i)=>i.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new ns;let t=0;for(const o of this.effects)if(o.blendMode.blendFunction===g.DST)e.attributes|=o.getAttributes()&K.DEPTH;else{if((e.attributes&o.getAttributes()&K.CONVOLUTION)!==0)throw new Error(`Convolution effects cannot be merged (${o.name})`);vi("e"+t++,o,e)}let i=e.shaderParts.get(T.FRAGMENT_HEAD),s=e.shaderParts.get(T.FRAGMENT_MAIN_IMAGE),n=e.shaderParts.get(T.FRAGMENT_MAIN_UV);const a=/\bblend\b/g;for(const o of e.blendModes.values())i+=o.getShaderCode().replace(a,`blend${o.blendFunction}`)+`
`;(e.attributes&K.DEPTH)!==0?(e.readDepth&&(s=`float depth = readDepth(UV);

	`+s),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,e.colorSpace===w&&(s+=`color0 = sRGBToLinear(color0);
	`),e.uvTransformation?(n=`vec2 transformedUv = vUv;
`+n,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(T.FRAGMENT_HEAD,i),e.shaderParts.set(T.FRAGMENT_MAIN_IMAGE,s),e.shaderParts.set(T.FRAGMENT_MAIN_UV,n);for(const[o,l]of e.shaderParts)l!==null&&e.shaderParts.set(o,l.trim().replace(/^#/,`
#`));this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=Z){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const i of this.effects)i.setDepthTexture(e,t)}render(e,t,i,s,n){for(const a of this.effects)a.update(e,t,s);if(!this.skipRendering||this.renderToScreen){const a=this.fullscreenMaterial;a.inputBuffer=t.texture,a.time+=s*this.timeScale,e.setRenderTarget(this.renderToScreen?null:i),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const i of this.effects)i.setSize(e,t)}initialize(e,t,i){this.renderer=e;for(const s of this.effects)s.initialize(e,t,i);this.updateMaterial(),i!==void 0&&i!==z&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){e.type==="change"&&this.recompile()}},_i=class extends U{constructor(e,t,{renderTarget:i,resolutionScale:s=1,width:n=P.AUTO_SIZE,height:a=P.AUTO_SIZE,resolutionX:o=n,resolutionY:l=a}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new li(e,t,new kt);const u=this.renderPass;u.ignoreBackground=!0,u.skipShadowMapUpdate=!0;const v=u.getClearPass();v.overrideClearColor=new rt(7829503),v.overrideClearAlpha=1,this.renderTarget=i,this.renderTarget===void 0&&(this.renderTarget=new N(1,1,{minFilter:ge,magFilter:ge}),this.renderTarget.texture.name="NormalPass.Target");const f=this.resolution=new P(this,o,l,s);f.addEventListener("change",m=>this.setSize(f.baseWidth,f.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,i,s,n){const a=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,a,a)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height)}};export{Ei as B,xi as D,Ti as E,vt as M,_i as N,Si as O,U as P,li as R,dt as a,Mi as b,bi as c};
