import { createHash } from "node:crypto";
import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";

import glob from "fast-glob";
import type { Plugin, ResolvedConfig } from "vite";

type Widget = {
    name: string;
    fileName: string;
    relativePath: string;
    absolutePath: string;
};

type WidgetManifest = Record<
    string,
    {
        name: string;
        uri: string;
        hash: string;
        originalPath: string;
    }
>;

async function generateWidgetManifest(
    widgets: Widget[],
    hashGenerator: (widget: Widget) => Promise<string> | string
): Promise<WidgetManifest> {
    const manifest: WidgetManifest = {};

    for (const widget of widgets) {
        const hash = await hashGenerator(widget);

        manifest[widget.name] = {
            name: widget.name,
            uri: `${widget.name}.${hash}`,
            hash,
            originalPath: widget.relativePath,
        };
    }

    return manifest;
}

function generateManifestContent(manifest: WidgetManifest): string {
    return `// This file is auto-generated by the widget-manifest Vite plugin
export const widgetManifest = ${JSON.stringify(manifest, null, 2)} as const;

export type WidgetName = keyof typeof widgetManifest;
`;
}

export function widgetManifest(): Plugin {
    const manifestFilePath = resolve(
        process.cwd(),
        "src/generated/widget-manifest.ts"
    );
    let viteConfig: ResolvedConfig;
    let logger: ResolvedConfig["logger"] | undefined;
    let widgets: Widget[] = [];

    return {
        name: "chatui-widget-manifest",
        sharedDuringBuild: true,

        config(_config) {
            // Discover all widget HTML files
            const discoveredWidgets = glob
                .sync(["src/**/index.html"], {
                    onlyFiles: true,
                    objectMode: true,
                })
                .map((file) => {
                    const relativePath = file.path;
                    const name = file.path.split("/")[1]; // Extract widget name from src/widget-name/index.html

                    return {
                        name,
                        fileName: file.name,
                        relativePath,
                        absolutePath: resolve(process.cwd(), file.path),
                    };
                });

            widgets = discoveredWidgets;

            // Auto-generate input entries for Vite
            const inputEntries = discoveredWidgets.reduce((acc, widget) => {
                acc[widget.name] = widget.absolutePath;
                return acc;
            }, {} as Record<string, string>);

            return {
                build: {
                    rollupOptions: {
                        input: inputEntries,
                    },
                },
            };
        },

        async configResolved(resolvedConfig) {
            viteConfig = resolvedConfig;
            logger = resolvedConfig.logger;

            if (viteConfig.command === "serve") {
                if (widgets.length === 0) {
                    logger?.warn(
                        "[widget-manifest] No widgets found. Cannot generate manifest in development."
                    );
                    return;
                }

                const devManifest = await generateWidgetManifest(widgets, () => {
                    return `dev-${Date.now()}`;
                });

                writeFileSync(manifestFilePath, generateManifestContent(devManifest));
                logger?.info(
                    `[widget-manifest] Generated development manifest for ${widgets.length} widgets`
                );
            }
        },

        configureServer: {
            handler: function widgetManifestMiddleware(server) {
                const redirectMap = new Map<string, string>();
                for (const widget of widgets) {
                    // Create clean URLs for development: /widget-name -> /src/widget-name/index.html
                    const cleanUrl = `/${widget.name}`;
                    redirectMap.set(cleanUrl, `/${widget.relativePath}`);
                }

                server.middlewares.use((req, res, next) => {
                    const urlToCheck = req.originalUrl || req.url;

                    if (urlToCheck && redirectMap.has(urlToCheck)) {
                        const redirectTo = redirectMap.get(urlToCheck)!;

                        server.config.logger?.info(
                            `[widget-manifest] Redirecting dev server URL: ${req.url} -> ${redirectTo}`
                        );

                        res.statusCode = 302;
                        res.setHeader("Location", redirectTo);
                        res.end();
                        return;
                    }

                    next();
                });
            },
        },

        writeBundle: {
            sequential: true,
            order: "post",
            async handler(options) {
                const outDir = options.dir;
                if (!outDir) return;

                if (widgets.length === 0) {
                    logger?.warn(
                        "[widget-manifest] No widgets found. Cannot generate build manifest."
                    );
                    return;
                }

                const buildManifest = await generateWidgetManifest(
                    widgets,
                    async (widget) => {
                        // Files are built to src/widget-name/index.html structure
                        const distPath = resolve(outDir, widget.relativePath);

                        if (!existsSync(distPath)) {
                            const err = new Error(
                                `Could not find widget ${widget.relativePath} in build output: ${distPath}`
                            );
                            throw err;
                        }

                        const widgetHtml = readFileSync(distPath, "utf-8");
                        const hash = createHash("sha256")
                            .update(widgetHtml)
                            .digest("hex")
                            .slice(0, 8);

                        this.info(
                            `[widget-manifest] Generated hash for ${widget.name}: ${hash}`
                        );

                        return hash;
                    }
                );

                writeFileSync(
                    manifestFilePath,
                    generateManifestContent(buildManifest)
                );
                this.info(
                    `[widget-manifest] Generated build manifest for ${widgets.length} widgets`
                );
            },
        },
    };
}
