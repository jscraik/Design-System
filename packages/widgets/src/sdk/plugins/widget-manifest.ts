import { createHash } from "node:crypto";
import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";

import glob from "fast-glob";
import type { Plugin, ResolvedConfig } from "vite";

/**
 * Internal widget metadata derived from discovered HTML entries.
 */
type Widget = {
  name: string;
  fileName: string;
  relativePath: string;
  absolutePath: string;
};

/**
 * Widget manifest mapping used by runtime tooling.
 */
type WidgetManifest = Record<
  string,
  {
    name: string;
    uri: string;
    hash: string;
    originalPath: string;
  }
>;

/**
 * Build a manifest mapping from discovered widgets.
 * @param widgets - Discovered widgets.
 * @param hashGenerator - Hash generator for each widget.
 * @returns A manifest mapping keyed by widget name.
 */
async function generateWidgetManifest(
  widgets: Widget[],
  hashGenerator: (widget: Widget) => Promise<string> | string,
): Promise<WidgetManifest> {
  const manifest: WidgetManifest = {};

  for (const widget of widgets) {
    const hash = await hashGenerator(widget);

    manifest[widget.name] = {
      name: widget.name,
      uri: `${widget.name}.${hash}`,
      hash,
      originalPath: widget.relativePath,
    };
  }

  return manifest;
}

/**
 * Serialize the manifest into a TypeScript module.
 * @param manifest - The manifest to serialize.
 * @returns The TypeScript module contents.
 */
function generateManifestContent(manifest: WidgetManifest): string {
  return `// This file is auto-generated by the widget-manifest Vite plugin
/**
 * Manifest entries keyed by widget name, with build hash metadata.
 */
export const widgetManifest = ${JSON.stringify(manifest, null, 2)} as const;

/**
 * Union of widget names present in the manifest.
 */
export type WidgetName = keyof typeof widgetManifest;
`;
}

/**
 * Create a Vite plugin that generates the widget manifest.
 * @returns The configured Vite plugin instance.
 */
export function widgetManifest(): Plugin {
  const manifestFilePath = resolve(process.cwd(), "src/sdk/generated/widget-manifest.ts");
  let viteConfig: ResolvedConfig;
  let logger: ResolvedConfig["logger"] | undefined;
  let widgets: Widget[] = [];

  return {
    name: "chatui-widget-manifest",
    sharedDuringBuild: true,

    config(_config) {
      // Discover all widget HTML files
      const discoveredWidgets = glob
        .sync(["src/widgets/**/index.html"], {
          onlyFiles: true,
          objectMode: true,
        })
        .map((file) => {
          const relativePath = file.path.replace(/\\/g, "/");
          const pathSegments = relativePath.split("/");
          const name = pathSegments[pathSegments.length - 2]; // Use leaf folder as widget name

          return {
            name,
            fileName: file.name,
            relativePath,
            absolutePath: resolve(process.cwd(), relativePath),
          };
        });

      widgets = discoveredWidgets;

      // Auto-generate input entries for Vite
      const inputEntries = discoveredWidgets.reduce(
        (acc, widget) => {
          acc[widget.name] = widget.absolutePath;
          return acc;
        },
        {} as Record<string, string>,
      );

      return {
        build: {
          rollupOptions: {
            input: inputEntries,
          },
        },
      };
    },

    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
      logger = resolvedConfig.logger;

      if (viteConfig.command === "serve") {
        if (widgets.length === 0) {
          logger?.warn(
            "[widget-manifest] No widgets found. Cannot generate manifest in development.",
          );
          return;
        }

        const devManifest = await generateWidgetManifest(widgets, () => {
          return `dev-${Date.now()}`;
        });

        writeFileSync(manifestFilePath, generateManifestContent(devManifest));
        logger?.info(
          `[widget-manifest] Generated development manifest for ${widgets.length} widgets`,
        );
      }
    },

    configureServer: {
      handler: function widgetManifestMiddleware(server) {
        const redirectMap = new Map<string, string>();
        for (const widget of widgets) {
          // Create clean URLs for development: /widget-name -> /src/**/index.html
          const cleanUrl = `/${widget.name}`;
          redirectMap.set(cleanUrl, `/${widget.relativePath}`);
        }

        server.middlewares.use((req, res, next) => {
          const urlToCheck = req.originalUrl || req.url;

          if (urlToCheck && redirectMap.has(urlToCheck)) {
            const redirectTo = redirectMap.get(urlToCheck)!;

            server.config.logger?.info(
              `[widget-manifest] Redirecting dev server URL: ${req.url} -> ${redirectTo}`,
            );

            res.statusCode = 302;
            res.setHeader("Location", redirectTo);
            res.end();
            return;
          }

          next();
        });
      },
    },

    writeBundle: {
      sequential: true,
      order: "post",
      async handler(options) {
        const outDir = options.dir;
        if (!outDir) return;

        if (widgets.length === 0) {
          logger?.warn("[widget-manifest] No widgets found. Cannot generate build manifest.");
          return;
        }

        const buildManifest = await generateWidgetManifest(widgets, async (widget) => {
          // Files are built to src/**/index.html structure
          const distPath = resolve(outDir, widget.relativePath);

          if (!existsSync(distPath)) {
            const err = new Error(
              `Could not find widget ${widget.relativePath} in build output: ${distPath}`,
            );
            throw err;
          }

          const widgetHtml = readFileSync(distPath, "utf-8");
          const hash = createHash("sha256").update(widgetHtml).digest("hex").slice(0, 8);

          this.info(`[widget-manifest] Generated hash for ${widget.name}: ${hash}`);

          return hash;
        });

        writeFileSync(manifestFilePath, generateManifestContent(buildManifest));
        this.info(`[widget-manifest] Generated build manifest for ${widgets.length} widgets`);
      },
    },
  };
}
